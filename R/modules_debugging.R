# This file contains Shiny modules useful for debugging and developing teal.
# We do not export the functions in this file, but show them in pkgdown. They are for
# developers only and can be accessed via `:::`.
# Examples are mostly provided in the vignette `developer_apps.Rmd`.

#' Dummy module to show the filter calls generated by the right encoding panel
#'
#' The `Show R Code` functionality is not available here because
#' it is only defined in `teal.devel`.
#'
#' Please do not remove, this is useful for debugging teal without
#' dependencies and simplifies `\link[devtools]{load_all}` which otherwise fails
#' and avoids session restarts!
#'
#' @param label `character` label of module
#' @param active_datanames `character vector` datanames shown in filter panel;
#'   can be `"all"` to mean all available datasets
#'
#' @examples
#' library(scda)
#' ADSL <- synthetic_cdisc_data("latest")$adsl
#' # by testing with NA values, we will see whether the filtering really works when
#' # we add and remove filters
#' ADSL$SEX[1:150] <- NA
#'
#' app <- init(
#'   data = cdisc_data(
#'     cdisc_dataset(
#'       dataname = "ADSL",
#'       x = ADSL
#'     ),
#'     code = "ADSL <- synthetic_cdisc_data(\"latest\")$adsl"
#'   ),
#'   modules = root_modules(
#'     teal:::filter_calls_module()
#'   ),
#'   header = "Simple teal app"
#' )
#' \dontrun{
#' shinyApp(app$ui, app$server)
#' }
filter_calls_module <- function(label = "Filter Calls Module", active_datanames = "all") { # nousage # nolint
  stopifnot(is_character_single(label))
  stopifnot(identical(active_datanames, "all") || is_character_vector(active_datanames))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      output$filter_calls <- renderText({
        active_datanames <- datasets$handle_active_datanames(active_datanames)
        get_filter_expr(datasets, datanames = active_datanames)
      })
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("The following filter calls are generated:"),
        verbatimTextOutput(ns("filter_calls"))
      )
    },
    filters = active_datanames
  )
}

#' Bookmarking module
#'
#' Presents a button that bookmarks the current state.
#' Note that Shiny does not bookmark uploaded files except when
#' `enableBookmarking` is set to `server`.
#' The module also prints a nice error message if bookmarking is not enabled.
#'
#' @inheritParams filter_calls_module
bookmark_module <- function(label = "Bookmark Module") { # nousage # nolint
  stopifnot(is_character_single(label))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$bookmark, {
        if (!isTRUE(getShinyOption("bookmarkStore") %in% c("url", "server"))) {
          # `isTRUE` because may be `NULL`
          showModal(modalDialog(
            title = "Bookmarking not enabled",
            paste0(
              "Shiny bookmarking option must be enabled, its value currently is: '",
              getShinyOption("bookmarkStore"), "'."
            )
          ))
        } else {
          session$doBookmark()
        }
      })

      setBookmarkExclude("bookmark") # we do not want the window to open when it is restored
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Bookmark"),
        bookmarkButton(id = ns("bookmark"))
      )
    },
    # we show all filters so the user sees in which state the datasets will be bookmarked
    filters = "all"
  )
}

#' Module that calls `browser()` on button click
#'
#' The module presents a button that will call `browser()` and also set the
#' option `"teal_debug"` so that code may behave differently with more verbose
#' statements when you are in the debug console. This option is only set while
#' you stay in the debugger.
#'
#' This is useful as breakpoints or global variables can be set in this way.
#' When you are developing another module and find a function not working
#' as expected, without restarting the app, you can call `debug(your_fcn)` and
#' then resume execution. On the next invocation of the function, it will
#' debug it.
#'
#' Currently not supported, but a good idea is to provide an argument that contains
#' code that is executed before `browser()` is called.
#'
#' @inheritParams filter_calls_module
debug_browser_module <- function(label = "Browser Debug Module") { # nousage # nolint
  stopifnot(is_character_single(label))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$call_browser, {
        # we also set a global option `teal_debug` so that the code can insert debug statements that trigger when in
        # this mode (but should be used for development purposes only):
        # `if (isTRUE(getOption("teal_debug"))) { debug_code }` #nolint
        fun <- function() {
          ori_state <- options("teal_debug")
          on.exit(options(teal_debug = ori_state))
          options(teal_debug = TRUE)
          # `browser()`, this escapes the regexp that checks for browser as it is needed here as part of the module
          do.call(browser, list())
          return(invisible(NULL))
        }
        fun()
      })
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Debugging"),
        p("Once in the console, you can type `debug(your_fcn)` and resume execution. This will then debug the function the next time it is called. For example, `debugonce(session$doBookmark)`. You can also access the datasets."), #nolint
        actionButton(ns("call_browser"), "Call browser()")
      )
    },
    filters = "all"
  )
}

#' Reset filters for the specified datasets
#'
#' The module presents a group of checkboxes to select the datasets for which to reset
#' all filters.
#'
#' @inheritParams filter_calls_module
reset_filters_module <- function(label = "Reset Filters Module", active_datanames = "all") { # nousage # nolint
  stopifnot(is_character_single(label))
  stopifnot(identical(active_datanames, "all") || is_character_vector(active_datanames))

  module(
    label = label,
    server = function(input, output, session, datasets) {
      observeEvent(input$reset, {
        # This works as expected because the filter panel on the right listens
        # for changes in the variable names for each dataname. (However, it does
        # not react to changes in the `filter_state` or `filter_info` of the variables.)
        lapply(
          input$datasets_to_reset,
          function(dataname) datasets$set_filter_state(dataname, state = list(), remove_omitted = TRUE)
        )
      })

      # reactive, handles "all" datanames
      active_datanames_r <- reactive(
        datasets$handle_active_datanames(active_datanames)
      )
      # The UI may not be ready yet, i.e. updating "datasets_to_reset" won't have any effect.
      # Therefore, we ignore the first reactive cycle. The UI is ready at the next reactive cycle.
      active_datanames_r_next_cycle <- trigger_after_first_cycle(active_datanames_r)
      observeEvent(active_datanames_r_next_cycle(), {
        # we want to run this once the "datasets_to_reset" UI exists
        updateCheckboxGroupInput(
          session, "datasets_to_reset",
          choices = active_datanames_r(), selected = active_datanames_r()
        )
      }, ignoreNULL = FALSE)
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Reset filters"),
        checkboxGroupInput(ns("datasets_to_reset"), "Datasets to reset:"),
        actionButton(ns("reset"), "Reset")
      )
    },
    filters = active_datanames
  )
}

#' Activates the reactive expression after the first reactive flush of Shiny,
#' This is useful when the UI does not exist yet and we want to wait for it
#' Note that this triggers the first time due to the timer and from then on due to
#' the expression being evaluated.
#'
#' Note: Usage of this function should be avoided as it is a workaround.
#'
#' ```
#' # This ensures that the input is evaluated in the second reactive flash
#' # (and possibly later as well)
#' get_name <- reactiveVal("hello")
#' get_name_ui_exists <- trigger_after_first_cycle(get_name)
#' observeEvent(
#'   get_name_ui_exists(),
#'   updateInput(session, "initially_inexistent_input", value = get_name_ui_exists())
#' )
#' ```
#'
#' @param expr `function or reactive`
#' @return `reactive`
# sodo1: do you like this code? I don't.
trigger_after_first_cycle <- function(expr) { # nousage # nolint
  stopifnot(is.function(expr))
  trigger_now <- FALSE
  reactive({
    if (!trigger_now) {
      trigger_now <<- TRUE
      invalidateLater(1) # will retrigger this and then go into else
    } else {
      expr()
    }
  })
}

# predefined_filters_module ----
# should be eventually moved into a proper module as the other modules in the files `module_<name>.R`
# and examples should be added

#' Add predefined filters with a button click
#'
#' For instance, one wants to add all filters at once for a safety analysis.
#'
#' After resetting to the predefined filters `filter`, the applied filters
#' will match exactly the `filter`.
#' There is a checkbox option to not reset those datanames that don't appear
#' in `filter`.
#' There is a checkbox option to not reset variables that are currently filtered
#' (but they must still appear in the `filter`, otherwise they are removed).
#'
#' **Note:**
#' The filters of all datasets are set, not just the active datanames
#' in the module's tab. Some datasets may be hidden from filtering, but the
#' filter state is still changed. However, the dataset is not immediately
#' recomputed, only lazily.
#' A drawback with the current approach is that the module computes on the full
#' dataset immediately after reset (which may take a lot of time) and the new
#' filter state is only applied in the next reactive cycle.
#'
#' @inheritParams filter_calls_module
#' @inheritParams init
#'
predefined_filters_module <- function(label = "Apply filters", filter) { # nousage # nolint
  stopifnot(
    is_character_single(label),
    is_fully_named_list(filter)
  )
  module(
    label = label,
    server = function(input, output, session, datasets) {
      # Note: use `datasets$datanames()` instead of `names(filters())`
      datanames <- reactive(datasets$datanames())

      # overwrite it to filter to only those datasets that are provided
      all_filters <- filter
      filters <- function() {
        # reactive
        res <- all_filters[names(all_filters) %in% datanames()]
        if (input$include_nonspecified_datasets) {
          # set datasets that don't appear to NULL so below we also loop over the datasets that
          # are not specified in the dataset
          datanames_to_add <- setdiff(datanames(), names(res))
          res[datanames_to_add] <- replicate(length(datanames_to_add), list())
        } # otherwise, all datasets that don't appear in the `filter` are not affected
        return(res)
      }

      set_dataset_filters <- function() {
        isolate(Map(function(dataname, filters) {
          datasets$set_filter_state(dataname, state = filters)
        }, names(filters()), filters()))
        invisible(NULL)
      }
      next_cycle_set_dataset_filters <- execute_in_next_cycle(set_dataset_filters)

      observeEvent(input$apply_filters, {
        # The filter panel on the right listens for changes in the variable names for
        # each dataname. However, it does not react to changes in the `filter_state` or `filter_info`
        # of the variables. Therefore, we must explicitly remove them for one reactive cycle
        # and then readd all variables on the next cycle.
        if (input$overwrite_filtered_vars) {
          # We entirely remove all variables and add them in the next cycle
          lapply(names(filters()), function(dataname) {
            datasets$set_filter_state(dataname, state = list(), remove_omitted = TRUE)
          })
          next_cycle_set_dataset_filters()
        } else {
          # We only remove those variables that are not part of the filter.
          # We keep the variable filter states that are part of the filter.
          Map(function(dataname, filters) {
            current_filters <- datasets$get_filter_state(dataname)
            vars_to_keep <- names(filters)[names(filters) %in% names(current_filters)]
            filters[vars_to_keep] <- current_filters[vars_to_keep]
            datasets$set_filter_state(dataname, state = filters)
          }, names(filters()), filters())
        }
      })

      # info about what will happen
      output$apply_info <- renderText({
        removed_vars <- Map(function(dataname, filters) {
          current_filters <- datasets$get_filter_state(dataname)
          if (input$overwrite_filtered_vars) {
            names(current_filters)
          } else {
            setdiff(names(current_filters), names(filters))
          }
        }, names(filters()), filters())

        # variables that will be added once the variables were removed
        added_vars <- Map(function(dataname, filters) {
          if (input$overwrite_filtered_vars) {
            names(filters)
          } else {
            current_filters <- datasets$get_filter_state(dataname)
            setdiff(names(filters), names(current_filters))
          }
        }, names(filters()), filters())

        # variables that will not be modified
        non_modified_vars <- Map(function(dataname, filters) {
          if (input$overwrite_filtered_vars) {
            NULL
          } else {
            current_filters <- datasets$get_filter_state(dataname)
            names(current_filters)[names(current_filters) %in% names(filters)]
          }
        }, names(filters()), filters())

        # Variables that will be present after applying it
        filter_vars <- lapply(filters(), names)

        if (!input$include_nonspecified_datasets) {
          # will not affect datasets that do not appear in `filters()`
          extra_datanames <- setNames(nm = setdiff(datanames(), names(filter())))
          # extra vars that will not be modified because they are not included in the filter
          extra_vars <- lapply(extra_datanames, function(dataname) {
            names(datasets$get_filter_state(dataname))
          })
          non_modified_vars <- c(non_modified_vars, extra_vars)
          filter_vars <- c(filter_vars, extra_vars)
        }

        named_list_to_string <- function(lst) {
          lst <- lapply(lst, toString)
          paste(
            names(lst), lst, sep = ": ", collapse = "\n"
          )
        }
        paste0(
          "The following variables will be removed: \n",
          named_list_to_string(removed_vars),
          "\n---------------------------------\n",
          "The following variables will be added (once variables were removed): \n",
          named_list_to_string(added_vars),
          "\n---------------------------------\n",
          "The following variables will not be modified: \n",
          named_list_to_string(non_modified_vars),
          "\n---------------------------------\n",
          "The following variables will be present after this operation (corresponding to filter): \n",
          named_list_to_string(filter_vars)
        )
      })
    },
    ui = function(id, ...) {
      ns <- NS(id)
      div(
        h2("Apply predefined filters"),
        checkboxInput(
          ns("overwrite_filtered_vars"),
          "Overwrite variables that will still be filtered (but possibly different filter settings)",
          width = "100%",
          value = TRUE
        ),
        # also remove variables for datasets that are not included in the filter
        checkboxInput(
          ns("include_nonspecified_datasets"),
          "Apply to datasets not included in the filter (removes their filters)",
          width = "100%",
          value = TRUE
        ),
        actionButton(ns("apply_filters"), "Apply filters"),
        verbatimTextOutput(ns("apply_info"))
      )
    },
    filters = "all"
  )
}

#' Execute the expression in the next reactive cycle
#'
#' Once it is made active, it executes the expression one reactive cycle after
#' 1. calling this function
#' 2. after it is invalidated (but it is only re-evaluated on the next reactive)
#' You can avoid case 2 by isolating any calls within `f`. Note that
#' `isolate(f)` won't work because `f` itself is not evaluated.
#'
#' This can be useful to make sure that first all current reactives finish before
#' executing the function.
#'
#' @param f `function` function / reactive to evaluate
#' @return `function` that returns a trigger to make it active
#' @examples
#' \dontrun{
#' smth_next_cycle <- execute_in_next_cycle(reactive(input$smth))
#' # make it active by calling it
#' smth_next_cycle()
#'
#' # Important: Make sure to not call `smth_next_cycle()` twice in the same
#' # reactive cycle, it would then evaluate it immediately. Instead,
#' # create the object `smth_next_cycle` twice.
#' }
#'
#' app <- shinyApp(ui = function() {
#'   div(
#'     actionButton("click", "Click me")
#'   )
#' }, server = function(input, output, session) {
#'   f <- function() {
#'     print(paste0("Called f: ", input$click))
#'   }
#'   set_dataset_in_next_cycle <- execute_in_next_cycle(f)
#'   observeEvent(input$click, {
#'     print("Clicked")
#'     set_dataset_in_next_cycle()
#'   })
#' })
#' \dontrun{
#' runApp(app)
#' }
execute_in_next_cycle <- function(f) { # nousage # nolint
  stopifnot(is.function(f))

  # reactiveVal to trigger re-evaluation of the expression when its value changes
  trigger_val <- reactiveVal(0)
  # whether it is executed now or in next reactive cycle
  executed <- FALSE
  observe({
    trigger_val()
    req(trigger_val() > 0)

    if (!executed) {
      invalidateLater(1)
      executed <<- TRUE
    } else {
      f()
      executed <<- FALSE
    }
  })
  # when called, triggers the function `f` to run in next cycle and also afterwards always one cycle after `f` triggers
  function() trigger_val(trigger_val() + 1)
}
