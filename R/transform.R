#' Transform a teal module
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Modify the module's ui or server functions.
#' Primary used to modify the output of the report.
#' @rdname transform
#' @name transform
#' @details
#' This method can overwrite the input or output of existing modules, or modify
#' the report generated by the module.
#'
#' @param _data (`teal_module` or `teal_modules`), which in case of `teal_modules` will apply
#' `transform` to each module in the list.
#' @param ui (`function(id, elem, ...)`) function to receive output (`shiny.tag`) from `_data$ui`.
#' @param server (`function(input, output, session, data, ...)`) function or a `function(id, data) moduleServer(...)`
#'  to receive output data from \code{`_data`$server}.
#' @param when A character vector with when should this modification be applied: `before`, `decorator` or `after`.
#' - `before`: Before the module is executed. Allows to change/update data or the UI.
#' - `decorator`: after the module is executed but applied to specific objects. Allows to modify specific objects.
#' - `after` (default) : after the module and decorators are executed. Allows to change reporter.
#' @param ... additional argument. Passed to `ui` and `server` by matching their parameters.
#' @return A `teal_module` object with the modifications.
#' @seealso To modify just the output see [`teal_transform_module`].
#' @export
#' @examples
#' library("teal.reporter")
#' app <- init(
#'   data = teal_data(IRIS = iris, MTCARS = mtcars),
#'   modules = example_module() |>
#'     transform(
#'       ui = function(id, elem) {
#'         ns <- NS(id)
#'         check_box <- checkboxInput(ns("src"), "Include R Code in the report", TRUE)
#'         htmltools::tagAppendChild(elem, check_box,
#'           .cssSelector = ".standard-layout .sidebar .sidebar-content"
#'         )
#'       },
#'       server = function(input, output, session, data) {
#'         teal_card(data) <- c(teal_card(data), teal_card("Modification"))
#'         if (!input$src) {
#'           teal_card(data) <- Filter(function(x) !inherits(x, "code_chunk"), teal_card(data))
#'         }
#'         data
#'       }
#'     )
#' )
#' if (interactive()) {
#'   runApp(app)
#' }
transform.teal_modules <- function(`_data`, # nolint: object_name
                                   ui = function(id, elem) elem,
                                   server = function(input, output, session, data) data,
                                   when = "after",
                                   ...) {
  `_data`$children <- lapply(`_data`$children, transform, ui = ui, server = server, ...) # nolint object_name_lintr
  `_data` # nolint object_name_lintr
}

#' @export
transform.teal_module <- function(`_data`, # nolint: object_name
                                  ui = function(id, elem) elem,
                                  server = function(input, output, session, data) data,
                                  when = "after",
                                  ...) {
  when <- match.arg(when, c("before", "decorator", "after"))

  names_ui <- names(formals(ui))
  if (!is.function(ui) || !"id" %in% names_ui) {
    stop("ui should be a function of `id` and optionally `elem`.")
  }

  names_srv <- names(formals(server))
  args_callModule <- c("input", "output", "session", "data")
  if (!is.function(server) || !(!all(identical(names_srv, c("id", "data"))) || !all(names_srv %in% args_callModule))) {
    stop("server should be a function of `input`, `output`, `session` and `data`")
  }

  additional_args <- list(...)
  # overwriting `_data`$ui/server causes infinite recursion
  tm <- `_data` # nolint: object_name_lintr

  if (identical(when, "before")) {
    ttm <- teal_transform_module(ui = ui, server = server)
    # add more assertions
    if ("elem" %in% names_ui) {
      warning("This allows to modify the UI. But requires to return the modified UI")
    }
    tm$transformators <- c(tm$transformators, list(ttm))
  } else if (identical(when, "decorator")) {
    ttm <- teal_transform_module(ui = ui, server = server)
    tm$server_args$decorators <- c(tm$server_args$decorators, list(ttm))
    tm$ui_args$decorators <- c(tm$ui_args$decorators, list(ttm))
    browser()
  } else {
    tm$ui <- transform_ui(tm$ui, ui, additional_args)
    tm$server <- transform_srv(tm$server, server, additional_args)
  }

  tm
}

# To support independent modification of ui and server we can't use .function dispatch
# transform server doesn't get the shiny Session: probably it can't be taken from the environment as expected.
# See: https://github.com/insightsengineering/teal/issues/1603

transform_ui <- function(old, new, additional_args) {
  new_ui <- function(id, ...) {
    original_args <- as.list(environment())
    if ("..." %in% names(formals(old))) {
      original_args <- c(original_args, list(...))
    }
    # Adding namespace id
    ns <- NS(id)
    original_args$id <- ns("wrapped")
    original_out <- do.call(old, original_args, quote = TRUE)

    wrapper_args <- c(additional_args, list(id = ns("wrapper"), elem = original_out))
    do.call(new, args = wrapper_args[names(formals(new))], quote = TRUE)
  }
  formals(new_ui) <- formals(old)
  new_ui
}

transform_srv <- function(old, new, additional_args) {
  new_srv <- function(id, ...) {
    original_args <- as.list(environment())

    moduleServer(id, function(input, output, session) {

      names_args_old <- names(formals(old))
      if ("..." %in% names_args_old) {
        orig_args <- c(original_args, list(...))
      } else {
        orig_args <- original_args
      }
      moduleServer_args <- c("input", "output", "session") # nolint object_name_lintr
      orig_args$id <-  session$ns("wrapped")
      # original module can be a function for callModule or for moduleServer
      old_out <- if (all(moduleServer_args %in% names_args_old)) {
        do.call(old, orig_args, quote = TRUE)
      } else {
        orig_args$module <- old
        valid_args_old <- unique(c(setdiff(names_args_old, "output"), "module", "id"))
        do.call(callModule, args = orig_args[valid_args_old], quote = TRUE)
      }

      wrapper_args <- utils::modifyList(
        additional_args,
        list(
          id = session$ns("wrapper"), input = input, output = output,
          session = session
        )
      )

      wrapper_args$data <- reactive({
        if (is.reactive(old_out)) {
          req(old_out())
        } else {
          old_out
        }
      })

      # new module can be a function for callModule or a function for moduleServer
      names_args_new <- names(formals(new))
      if (all(moduleServer_args %in% names_args_new)) {
        do.call(new, wrapper_args[names_args_new], quote = TRUE)
      } else {
        # Adding the module to the list passed to callModule with valid arguments
        wrapper_args$module <- new
        valid_args_new <- unique(c(setdiff(names_args_new, "output"), "module", "id"))
        do.call(shiny::callModule, args = wrapper_args[valid_args_new], quote = TRUE)
      }
    })
  }
  formals(new_srv) <- formals(old)
  new_srv
}
