#' Modificates a teal module
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Modify the module's ui or server functions.
#' Primary used to modify the output of the report.
#' @rdname transform
#' @name transform
#' @details
#' This method can overwrite the input or output of existing modules, or modify
#' the report generated by the module.
#'
#' @param _data (`teal_module` or `teal_modules`), which in case of `teal_modules` will apply
#' `transform` to each module in the list.
#' @param ui (`function(id, elem, ...)`) function to receive output (`shiny.tag`) from `_data$ui`.
#' @param server (`function(input, output, session, data, ...)`) function to receive output data from `_data$server`.
#' @param when A character vector with when should this modification be applied: `before` or `after`.
#' Default `after`, as before is equivalent to having a transformer on the module.
#' @param ... additional argument. Passed to `ui` and `server` by matching their formals names or to `teal_transform_module`.
#' @return A `teal_module` object with the modifications.
#' New element ids are under `wrapper` namespace, old elements' ids are on the `wrapped` namespace.
#' @seealso To modify just the output see [`teal_transform_module`].
#' @export
#' @examples
#' library("teal.reporter")
#' app <- init(
#'   data = teal_data(IRIS = iris, MTCARS = mtcars),
#'   modules = example_module() |>
#'     transform(
#'       ui = function(id, elem) {
#'         ns <- NS(id)
#'         check_box <- checkboxInput(ns("src"), "Include R Code in the report", TRUE)
#'         htmltools::tagAppendChild(elem, check_box,
#'           .cssSelector = ".standard-layout .sidebar .sidebar-content"
#'         )
#'       },
#'       server = function(input, output, session, data) {
#'         teal_card(data) <- c(teal_card(data), teal_card("Modification"))
#'         if (!input$`wrapper-src`) {
#'           teal_card(data) <- Filter(function(x) !inherits(x, "code_chunk"), teal_card(data))
#'         }
#'         data
#'       }
#'     )
#' )
#' if (interactive()) {
#'   runApp(app)
#' }
transform.teal_modules <- function(`_data`,
                               ui = function(id, elem) elem,
                               server = function(input, output, session, data) data,
                               when = "after",
                               ...) {
  `_data`$children <- lapply(`_data`$children, transform, ui = ui, server = server, ...)
  `_data`
}

#' @export
transform.teal_module <- function(`_data`,
                              ui = function(id, elem) elem,
                              server = function(input, output, session, data) data,
                              when = "after",
                              ...) {

  when <- match.arg(when, c("before", "after"))
  # todo: make a method for teal_app and remove teal_extend_server?
  # Check ui && server have required arguments but nothing else
  if (!is.function(ui) || !all(names(formals(ui)) %in% c("id", "elem"))) {
    stop("ui should be a function of `id` and `elem`.")
  }
  if (!is.function(server) || !all(names(formals(server)) %in% c("input", "output", "session", "data"))) {
    stop("server should be a function of `input`, `output`, `session` and `data`")
  }

  additional_args <- list(...)
  tm <- `_data` # because overwriting x$ui/server will cause infinite recursion

  if (identical(when, "before")) {
    # NOTE: Doesn't work, the attribute is not used
    # Apply each modification to the exiting transformators? Add to the end?
    # attr(tm, "transformators") <- c(
    #   attr(tm, "transformators"),
    #   teal_transform_module(ui, server, ...)
    # )
    # NOTE: Requires an id with just id as parameters; from module_transform_data.R#48: data_mod$ui(id = ns("transform"))

    tm$transformators <- if (is.list(tm$transformators) && !length(tm$transformators)) {
      list(teal_transform_module(server = server, ui = ui, ...))
    } else {
      list(tm$transformators, teal_transform_module(server = server, ui = ui, ...))
    }

    # transform_ui(tm$transformators$ui, ui, additional_args)
    # transform_srv(tm$transformators$server, server, additional_args)
    # formals(tm)["transformators"] <- teal_transform_module(ui, server, ...)
  } else {
    tm$ui <- transform_ui(tm$ui, ui, additional_args)
    tm$server = transform_srv(tm$server, server, additional_args)
  }
  tm
}

# Doesn't work: it doesn't get the shiny Session: probably it can't be taken from the environment as expected.
# transform.function <- function(old, new, additional_args) {
#   if (all(names(formals(old)) %in% c("id", "elem"))) {
#     transform_ui(old, new, additional_args)
#   } else {
#     transform_srv(old, new, additional_args)
#   }
# }

transform_ui <- function(old_ui, new_ui, additional_args) {
  new_fn <- function(id, ...) {
    original_args <- as.list(environment())
    if ("..." %in% names(formals(old_ui))) {
      original_args <- c(original_args, list(...))
    }
    ns <- NS(id)
    original_args$id <- ns("wrapped")
    original_out <- do.call(old_ui, original_args, quote = TRUE)

    wrapper_args <- c(
      additional_args,
      list(id = ns("wrapper"), elem = original_out)
    )
    do.call(new_ui, args = wrapper_args[names(formals(new_ui))])
  }
  formals(new_fn) <- formals(old_ui)
  new_fn
}

transform_srv <- function(old_srv, new_srv, additional_args) {
  new_fn <- function(id, ...) {
    original_args <- as.list(environment())
    original_args$id <- "wrapped"
    if ("..." %in% names(formals(old_srv))) {
      original_args <- c(original_args, list(...))
    }
    moduleServer(id, function(input, output, session) {
      original_out <- if (all(c("input", "output", "session") %in% names(formals(old_srv)))) {
        original_args$module <- old_srv
        do.call(shiny::callModule, args = original_args)
      } else {
        do.call(old_srv, original_args)
      }

      wrapper_args <- utils::modifyList(
        additional_args,
        list(
          id = "wrapper", input = input, output = output,
          session = session
        )
      )

      reactive({
        output <- if (is.reactive(original_out)) {
          original_out()
        } else {
          original_out
        }
        wrapper_args$data <- output
        do.call(new_srv, wrapper_args[names(formals(new_srv))], quote = TRUE)
      })
    })
  }
  formals(new_fn) <- formals(old_srv)
  new_fn
}
