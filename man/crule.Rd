% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{crule}
\alias{crule}
\title{Add condition to rule function.}
\usage{
crule(rule, condition, ...)
}
\arguments{
\item{rule}{\code{function} or \code{formula} that specifies a validation rule and a failing message}

\item{condition}{\code{call} that specifies when to check \code{rule}, see \code{Details}}

\item{...}{additional arguments passed to \code{rule}}
}
\value{
Returns a closure, ready to be placed into a \code{iv$add_rule} call as a rule function.
}
\description{
Adds a condition to a rule function to be used in an \code{InputValidator}.
}
\details{
When building a \code{shinyvalidate::InputValidator}, some rules may only need to be checked
under specific conditions. Since an input value must not be validated by multiple
validator objects (as per \code{shinyvalidate} documentation),
some validation scenarios cannot be covered by adding \code{condition}s to a whole validator.

This function takes a function or formula that can be used as a validation rule
and incorporates \code{condition} into its body, upstream of the actual test.

In cases where \code{condition} relies in input values, it is safer to wrap \code{condition}
in an \code{isTRUE} call so that NA or NULL does not crash evaluation.
For example, \code{input$id == "x"} will return \code{logical(0)} if input$id is NULL
and \code{NA} if input$id is NA, whereas \code{isTRUE(input$id == "x")} will reliably return \code{FALSE}.
}
\examples{
\dontrun{
library(shinyvalidate)

set <- c("element1", "element2")

custom_rule <- function(value) {
  if (! value \%in\% set) sprintf("id must be a set of \%s", paste(set, collapse = ", "))
}

iv <- InputValidator$new()
iv$add_rule("id", sv_required())
iv$add_rule("id", crule(custom_rule, !is.null(set)))
}

}
\seealso{
\verb{[shinyvalidate::InputValidator]}
}
