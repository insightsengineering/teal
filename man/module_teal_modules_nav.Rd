% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_nested_tabs.R
\name{module_teal_modules_nav}
\alias{module_teal_modules_nav}
\alias{ui_teal_modules_nav_dropdown}
\alias{ui_teal_modules_nav_dropdown.teal_modules}
\alias{ui_teal_modules_nav_dropdown.teal_module}
\alias{ui_teal_module}
\alias{ui_teal_module.default}
\alias{ui_teal_module.teal_modules}
\alias{ui_teal_module.teal_module}
\alias{srv_teal_module}
\alias{srv_teal_module.default}
\alias{srv_teal_module.teal_modules}
\alias{srv_teal_module.teal_module}
\title{Calls all \code{modules}}
\usage{
ui_teal_modules_nav_dropdown(id, modules, active_module_id)

\method{ui_teal_modules_nav_dropdown}{teal_modules}(id, modules, active_module_id)

\method{ui_teal_modules_nav_dropdown}{teal_module}(id, modules, active_module_id)

ui_teal_module(id, modules, active_module_id)

\method{ui_teal_module}{default}(id, modules, active_module_id)

\method{ui_teal_module}{teal_modules}(id, modules, active_module_id)

\method{ui_teal_module}{teal_module}(id, modules, active_module_id)

srv_teal_module(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{default}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{teal_modules}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{teal_module}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)
}
\arguments{
\item{id}{(\code{character(1)}) \code{shiny} module instance id.}

\item{modules}{(\code{teal_modules})
\code{teal_modules} object. These are the specific output modules which
will be displayed in the \code{teal} application. See \code{\link[=modules]{modules()}} and \code{\link[=module]{module()}} for
more details.}

\item{active_module_id}{(\code{reactive} returning \code{character(1)})
\code{id} of the currently active module. This helps to determine which module can listen to reactive events.}

\item{data}{(\code{reactive} returning \code{teal_data})}

\item{datasets}{(\code{reactive} returning \code{FilteredData} or \code{NULL})
When \code{datasets} is passed from the parent module (\code{srv_teal}) then \code{dataset} is a singleton
which implies the filter-panel to be "global". When \code{NULL} then filter-panel is "module-specific".}

\item{slices_global}{(\code{reactiveVal} returning \code{modules_teal_slices})
see \code{\link{module_filter_manager}}}

\item{data_load_status}{(\code{reactive} returning \code{character(1)})
Determines action dependent on a data loading status:
\itemize{
\item \code{"ok"} when \code{teal_data} is returned from the data loading.
\item \code{"teal_data_module failed"} when \code{\link[=teal_data_module]{teal_data_module()}} didn't return \code{teal_data}. Disables tab buttons.
\item \code{"external failed"} when a \code{reactive} passed to \code{srv_teal(data)} didn't return \code{teal_data}. Hides the whole tab
panel.
}}
}
\value{
Output of currently active module.
\itemize{
\item \code{srv_teal_module.teal_module} returns \code{reactiveVal} containing output of the called module.
\item \code{srv_teal_module.teal_modules} returns output of module selected by drop-down.
\item \code{srv_teal_modules_nav} bypasses output of \code{srv_teal_module.teal_modules}.
}
}
\description{
Module calls \code{modules} with \code{id} according to their location in the tree. There are multiple modules
managing this process:
\itemize{
\item \code{ui/srv_teal_modules_nav} container module where \code{input$active_module_id} exists.
\item \code{ui_teal_modules_nav_dropdown} creates drop-down menu to select active module.
\item \code{ui/srv_teal_module} creates tab containers for each module. Only one module is visible at the time as a result
of selecting in \code{ui_teal_modules_nav_dropdown}.
}
}
\details{
\subsection{UI}{

On the UI side, a drop-down is created that lists buttons labeled with the labels of all \code{teal_module}s.
The buttons in the drop-down are grouped according to their respective groups.
These UI components are created in a way to utilize navigation-bar functionality of shiny.
To achieve this, the buttons need to be placed inside a \verb{<ul class = "nav shiny-tab-input">}.
\enumerate{
\item Each module button has following attributes:
}
\itemize{
\item \code{href = "#<teal_module container id>"} links button with the container of the specific \code{teal_module}
\item \code{data-bs-toggle = "tab"} tells Bootstrap to hide or show \code{teal_module}'s content
\item \code{data-value = "<teal_module$path>"} This attribute is taken by shiny from all buttons of class "active"
and used as \code{input$active_module_id} in the namespace of \code{\link[=srv_teal_modules_nav]{srv_teal_modules_nav()}}.
}
\enumerate{
\item Each module content is wrapped in a container with the \code{class = "tab-pane"} with a unique \code{id}.
This tells Bootstrap library that clicking a button should toggle relevant "tab"
with an \code{id} matching button's \code{href} attribute.
}
}

\subsection{Server}{

On the server side, \code{teal_module}(s) are called with \code{id} respective to their label and group.
\code{input$active_module_id} determines which module is currently active and only this module
observes reactive changes.
}

\subsection{Initialization and isolation of the \code{teal_module}(s)}{

Modules are initialized only when they are active. This speeds up app initialization and on
startup only the first module is activated and its outputs are calculated.
Only the active module is listening to reactive events. This way, modules are isolated and only
one can run at any given time. This makes the app more efficient by reducing unnecessary
computations on server side.
}
}
\keyword{internal}
