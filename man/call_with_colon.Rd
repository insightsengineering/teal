% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call_utils.R
\name{call_with_colon}
\alias{call_with_colon}
\title{Create a call using a function in a given namespace}
\usage{
call_with_colon(name, ..., unlist_args = list())
}
\arguments{
\item{name}{\code{character} function name, possibly using namespace colon \code{::}, also
works with \code{:::} (sometimes needed, but strongly discouraged)}

\item{...}{arguments to pass to function with name \code{name}}

\item{unlist_args}{\code{list} extra arguments passed in a single list,
avoids the use of \code{do.call} with this function}
}
\description{
The arguments in ... need to be quoted because they will be evaluated otherwise
}
\examples{

print_call_and_eval <- function(x) {
  eval(print(x))
}

print_call_and_eval(
  call_with_colon("glue::glue", "x = {x}", x = 10)
)
\dontrun{
# mtcars$cyl evaluated
print_call_and_eval(
  call_with_colon("dplyr::filter", as.name("mtcars"), mtcars$cyl == 6)
)

# mtcars$cyl argument not evaluated immediately (in call expression)
print_call_and_eval(
  call_with_colon("dplyr::filter", as.name("mtcars"), quote(cyl == 6))
)

# does not work because argument is evaluated and the
# non-dplyr filter does not look inside mtcars
# cannot eval becausee it does not pass checks because of non-standard evaluation
call("filter", as.name("mtcars"), quote(cyl == 6))
# works, but non-dplyr filter is taken
call("filter", as.name("mtcars"), mtcars$cyl == 6)

nb_args <- function(...) nargs()
print_call_and_eval(
  call_with_colon("nb_args", arg1 = 1, unlist_args = list(arg2 = 2, args3 = 3))
)
# duplicate arguments
print_call_and_eval(
  call_with_colon("nb_args", arg1 = 1, unlist_args = list(arg2 = 2, args2 = 2))
)
}
}
\keyword{internal}
