% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_nested_tabs.R
\name{module_teal_module}
\alias{module_teal_module}
\alias{ui_teal_modules_nav_dropdown}
\alias{ui_teal_modules_nav_dropdown.teal_modules}
\alias{ui_teal_modules_nav_dropdown.teal_module}
\alias{srv_teal_modules_nav}
\alias{ui_teal_module}
\alias{ui_teal_module.default}
\alias{ui_teal_module.teal_modules}
\alias{ui_teal_module.teal_module}
\alias{srv_teal_module}
\alias{srv_teal_module.default}
\alias{srv_teal_module.teal_modules}
\alias{srv_teal_module.teal_module}
\title{Calls all \code{modules}}
\usage{
ui_teal_modules_nav_dropdown(id, modules, input_id, active_module_id)

\method{ui_teal_modules_nav_dropdown}{teal_modules}(id, modules, input_id, active_module_id)

\method{ui_teal_modules_nav_dropdown}{teal_module}(id, modules, input_id, active_module_id)

srv_teal_modules_nav(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok")
)

ui_teal_module(id, modules, active_module_id)

\method{ui_teal_module}{default}(id, modules, active_module_id)

\method{ui_teal_module}{teal_modules}(id, modules, active_module_id)

\method{ui_teal_module}{teal_module}(id, modules, active_module_id)

srv_teal_module(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{default}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{teal_modules}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)

\method{srv_teal_module}{teal_module}(
  id,
  data,
  modules,
  datasets = NULL,
  slices_global,
  reporter = teal.reporter::Reporter$new(),
  data_load_status = reactive("ok"),
  active_module_id = reactive(TRUE)
)
}
\arguments{
\item{id}{(\code{character(1)}) \code{shiny} module instance id.}

\item{modules}{(\code{teal_modules})
\code{teal_modules} object. These are the specific output modules which
will be displayed in the \code{teal} application. See \code{\link[=modules]{modules()}} and \code{\link[=module]{module()}} for
more details.}

\item{data}{(\code{reactive} returning \code{teal_data})}

\item{datasets}{(\code{reactive} returning \code{FilteredData} or \code{NULL})
When \code{datasets} is passed from the parent module (\code{srv_teal}) then \code{dataset} is a singleton
which implies in filter-panel to be "global". When \code{NULL} then filter-panel is "module-specific".}

\item{slices_global}{(\code{reactiveVal} returning \code{modules_teal_slices})
see \code{\link{module_filter_manager}}}

\item{data_load_status}{(\code{reactive} returning \code{character})
Determines action dependent on a data loading status:
\itemize{
\item \code{"ok"} when \code{teal_data} is returned from the data loading.
\item \code{"teal_data_module failed"} when \code{\link[=teal_data_module]{teal_data_module()}} didn't return  \code{teal_data}. Disables tabs buttons.
\item \code{"external failed"} when a \code{reactive} passed to \code{srv_teal(data)} didn't return \code{teal_data}. Hides the whole tab
panel.
}}
}
\value{
output of currently active module.
\itemize{
\item \code{srv_teal_module.teal_module} returns \code{reactiveVal} containing output of the called module.
\item \code{srv_teal_module.teal_modules} returns output of module selected by drop-down.
}
}
\description{
Module call \code{modules} with \code{id} according to their location in the three.
\subsection{UI}{

On the UI side, a drop-down is created that lists buttons labeled with the names of all \code{teal_module}s.
The buttons in the drop-down are grouped according to their respective groups.
These UI components are created in a way to utilize navigation-bar functionality of shiny.
To achieve this, the buttons need to be placed inside a \verb{<ul class = "nav shiny-tab-input">}.
\enumerate{
\item Each module button has following attributes:
}
\itemize{
\item \verb{href = "#<module id>} links button with the specific module content
\item \code{data-bs-toggle = "tab"} tells Bootstrap to hide or show module's content
\item \verb{data-value = "<module id>} returns this value to the shiny server as an input
linked to the \code{id} of the \code{ul} which is \code{input$active_module_id}.
}
\enumerate{
\item Each module content is wrapped in a container with the \code{class = "tab-pane"} with a unique \code{id}.
This tells Bootstrap library that clicking a button should toggle relevant "tab"
with an \code{id} matching button's \code{href} attribute.
}
}

\subsection{Server}{

On the server side, \code{teal_module}(s) are called with \code{id} respective to their label and group.
\code{input$active_module_id} determines which module is currently active and only this module
observes reactive changes.
}
}
\keyword{internal}
