% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gather_fails.R
\name{gather_fails}
\alias{gather_fails}
\alias{gather_fails_com}
\alias{gather_fails_grp}
\title{send input validation messages to output}
\usage{
gather_fails(iv, header = "Some inputs require attention", ...)

gather_fails_com(..., header = "Some inputs require attention")

gather_fails_grp(validators, ...)
}
\arguments{
\item{iv}{object of class \code{InputValidator}}

\item{header}{\code{character(1)} optional generic validation message}

\item{...}{for \code{gather_fails} and \code{gather_fails_grp} arguments passed to \code{shiny::validate}\cr
for \code{gather_fails_com} any number of \code{InputValidator} objects}

\item{validators}{optionally named \code{list} of \code{InputValidator} objects, see \code{Details}}
}
\value{
Returns NULL if the final validation call passes and a \code{shiny.silent.error} if it fails.
}
\description{
Captures messages from \code{InputValidator} objects and collates them
into one message passed to \code{validate}.
}
\details{
\code{shiny::validate} is used to withhold rendering of an output element until
certain conditions are met and a print a validation message in place
of the output element.
\code{shinyvalidate::InputValidator} allows to validate input elements
and display specific messages in their respective input widgets.
This function is a hybrid solution. Given an \code{InputValidator} object,
it extracts messages from inputs that fail validation and places them all in one
validation message that is passed to a \code{validate}/\code{need} call.
This way the input validator messages are repeated in the output.

\code{gather_fails} accepts one \code{InputValidator}
and can add a header to its validation messages.
\code{gather_fails_com} accepts an arbitrary number of \code{InputValidator}s
and prints all messages together under one header.
\code{gather_fails_grp} accepts a \strong{list} of \code{InputValidator}s
and prints messages in groups. If elements of \code{validators} are named,
the names are used as headers for their respective message groups.
}
\examples{
library(shiny)
library(shinyvalidate)

ui <- fluidPage(
  selectInput("method", "validation method", c("hierarchical", "combined", "grouped")),
  sidebarLayout(
    sidebarPanel(
      selectInput("letter", "select a letter:", c(letters[1:3], LETTERS[4:6])),
      selectInput("number", "select a number:", 1:6),
      br(),
      selectInput("color", "select a color:",
        c("black", "indianred2", "springgreen2", "cornflowerblue"),
        multiple = TRUE
      ),
      sliderInput("size", "select point size:",
        min = 0.1, max = 4, value = 0.25
      )
    ),
    mainPanel(plotOutput("plot"))
  )
)

server <- function(input, output) {
  # set up input validation
  iv <- InputValidator$new()
  iv$add_rule("letter", sv_in_set(LETTERS, "choose a capital letter"))
  iv$add_rule("number", ~ if (as.integer(.) \%\% 2L == 1L) "choose an even number")
  iv$enable()
  # more input validation
  iv_par <- InputValidator$new()
  iv_par$add_rule("color", sv_required(message = "choose a color"))
  iv_par$add_rule("color", ~ if (length(.) > 1L) "choose only one color")
  iv_par$add_rule(
    "size",
    sv_between(
      left = 0.5, right = 3,
      message_fmt = "choose a value between {left} and {right}"
    )
  )
  iv_par$enable()

  output$plot <- renderPlot({
    # validate output
    switch(input[["method"]],
      "hierarchical" = {
        gather_fails(iv)
        gather_fails(iv_par, "Set proper graphical parameters")
      },
      "combined" = gather_fails_com(iv, iv_par),
      "grouped" = gather_fails_grp(list(
        "Some inputs require attention" = iv,
        "Set proper graphical parameters" = iv_par
      ))
    )

    plot(eruptions ~ waiting, faithful,
      las = 1, pch = 16,
      col = input[["color"]], cex = input[["size"]]
    )
  })
}

if (interactive()) {
  shinyApp(ui, server)
}
}
\seealso{
\code{[shinyvalidate::InputValidator]} \code{[shiny::validate]}
}
