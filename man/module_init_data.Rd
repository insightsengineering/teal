% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_init_data.R
\name{module_init_data}
\alias{module_init_data}
\alias{ui_init_data}
\alias{srv_init_data}
\title{Data Module for teal}
\usage{
ui_init_data(id, data = NULL)

srv_init_data(
  id,
  data,
  modules,
  filter = teal_slices(),
  is_data_failed = reactiveValues()
)
}
\arguments{
\item{id}{(\code{character}) Optionally,
a string specifying the \code{shiny} module id in cases it is used as a \code{shiny} module
rather than a standalone \code{shiny} app. This is a legacy feature.}

\item{data}{(\code{teal_data}, \code{teal_data_module}, or \code{reactive} returning \code{teal_data})
The \code{ui} component of this module does not require \code{data} if \code{teal_data_module} is not provided.
The \code{data} argument in the \code{ui} is included solely for the \verb{$ui} function of the
\code{teal_data_module}. Otherwise, it can be disregarded, ensuring that \code{ui_teal} does not depend on
the reactive data of the enclosing application.}

\item{modules}{(\code{list} or \code{teal_modules} or \code{teal_module})
Nested list of \code{teal_modules} or \code{teal_module} objects or a single
\code{teal_modules} or \code{teal_module} object. These are the specific output modules which
will be displayed in the \code{teal} application. See \code{\link[=modules]{modules()}} and \code{\link[=module]{module()}} for
more details.}

\item{filter}{(\code{teal_slices}) Optionally,
specifies the initial filter using \code{\link[=teal_slices]{teal_slices()}}.}
}
\value{
A \code{reactive} object that returns:
\itemize{
\item \code{teal_data} when the object is validated
\item \code{shiny.silent.error} when not validated.
}
}
\description{
This module manages the \code{data} argument for \code{srv_teal}. The \code{teal} framework uses \code{\link[=teal_data]{teal_data()}},
which can be provided in various ways:
\enumerate{
\item Directly as a \code{\link[teal.data:teal_data]{teal.data::teal_data()}} object. This will automatically convert it into a \code{reactive} \code{teal_data}.
\item As a \code{reactive} object that returns a \code{\link[teal.data:teal_data]{teal.data::teal_data()}} object.
}
}
\details{
\subsection{Reactive \code{teal_data}:}{

The data in the application can be reactively updated, prompting \code{\link[=srv_teal]{srv_teal()}} to rebuild the
content accordingly. There are two methods for creating interactive \code{teal_data}:
\enumerate{
\item Using a \code{reactive} object provided from outside the \code{teal} application. In this scenario,
reactivity is controlled by an external module, and \code{srv_teal} responds to changes.
\item Using \code{\link[=teal_data_module]{teal_data_module()}}, which is embedded within the \code{teal} application, allowing data to
be resubmitted by the user as needed.
}

Since the server of \code{\link[=teal_data_module]{teal_data_module()}} must return a \code{reactive} \code{teal_data} object, both
methods (1 and 2) produce the same reactive behavior within a \code{teal} application. The distinction
lies in data control: the first method involves external control, while the second method
involves control from a custom module within the app.

For more details, see \code{\link{module_teal_data}}.
}
}
\keyword{internal}
