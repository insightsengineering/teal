% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modules_debugging.R
\name{execute_in_next_cycle}
\alias{execute_in_next_cycle}
\title{Execute the expression in the next reactive cycle}
\usage{
execute_in_next_cycle(f)
}
\arguments{
\item{f}{\code{function} function / reactive to evaluate}
}
\value{
\code{function} that returns a trigger to make it active
}
\description{
Once it is made active, it executes the expression one reactive cycle after
\enumerate{
\item calling this function
\item after it is invalidated (but it is only re-evaluated on the next reactive)
You can avoid case 2 by isolating any calls within \code{f}. Note that
\code{isolate(f)} won't work because \code{f} itself is not evaluated.
}
}
\details{
This can be useful to make sure that first all current reactives finish before
executing the function.
}
\examples{
\dontrun{
smth_next_cycle <- execute_in_next_cycle(reactive(input$smth))
# make it active by calling it
smth_next_cycle()

# Important: Make sure to not call `smth_next_cycle()` twice in the same
# reactive cycle, it would then evaluate it immediately. Instead,
# create the object `smth_next_cycle` twice.
}

app <- shinyApp(ui = function() {
  div(
    actionButton("click", "Click me")
  )
}, server = function(input, output, session) {
  f <- function() {
    print(paste0("Called f: ", input$click))
  }
  set_dataset_in_next_cycle <- execute_in_next_cycle(f)
  observeEvent(input$click, {
    print("Clicked")
    set_dataset_in_next_cycle()
  })
})
\dontrun{
runApp(app)
}
}
\keyword{internal}
