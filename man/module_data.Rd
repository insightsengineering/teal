% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1.0_module_data.R
\name{module_data}
\alias{module_data}
\alias{ui_data}
\alias{srv_data}
\title{Data module for teal}
\usage{
ui_data(id, data, title, header, footer)

srv_data(id, data, modules, filter = teal_slices())
}
\arguments{
\item{id}{(\code{character}) optional
string specifying the \code{shiny} module id in cases it is used as a \code{shiny} module
rather than a standalone \code{shiny} app. This is a legacy feature.}

\item{data}{(\code{teal_data}, \code{teal_data_module} or \code{reactive} returning \code{teal_data})}

\item{title}{(\code{shiny.tag} or \code{character(1)})
The browser window title. Defaults to a title "teal app" with the icon of NEST.
Can be created using the \code{build_app_title()} or
by passing a valid \code{shiny.tag} which is a head tag with title and link tag.}

\item{header}{(\code{shiny.tag} or \code{character(1)})
The header of the app.}

\item{footer}{(\code{shiny.tag} or \code{character(1)})
The footer of the app.}

\item{modules}{(\code{list} or \code{teal_modules} or \code{teal_module})
nested list of \code{teal_modules} or \code{teal_module} objects or a single
\code{teal_modules} or \code{teal_module} object. These are the specific output modules which
will be displayed in the \code{teal} application. See \code{\link[=modules]{modules()}} and \code{\link[=module]{module()}} for
more details.}

\item{filter}{(\code{teal_slices})
Specifies the initial filter using \code{\link[=teal_slices]{teal_slices()}}.}
}
\value{
A \code{reactiveVal} which is set to:
\itemize{
\item \code{teal_data} when the object is validated
\item \code{NULL} when not validated.
Important: \code{srv_data} suppress validate messages and returns \code{NULL} so that \code{srv_teal} can
stop the reactive cycle as \code{observeEvent} calls based on the data have \code{ignoreNULL = TRUE}.
}
}
\description{
Fundamental data class for teal is \code{\link[teal.data:teal_data]{teal.data::teal_data()}}. Data can be
passed in multiple ways:
\enumerate{
\item Directly as a \code{\link[teal.data:teal_data]{teal.data::teal_data()}} object.
\item As a \code{reactive} object returning \code{\link[teal.data:teal_data]{teal.data::teal_data()}}. \href{#reactive-teal_data}{See section}.
}
}
\section{Reactive \code{teal_data}}{


\code{\link[teal.data:teal_data]{teal.data::teal_data()}} can change depending on the reactive context and \code{srv_teal} will rebuild
the app accordingly. There are two ways of interacting with the data:
\enumerate{
\item Using a \code{reactive} object passed from outside the \code{teal} application. In this case, reactivity
is controlled by external module and \code{srv_teal} will trigger accordingly to the changes.
\item Using \code{\link[=teal_data_module]{teal_data_module()}} which is embedded in the \code{teal} application and data can be
resubmitted when needed by the user.
}

Since server of \code{\link[=teal_data_module]{teal_data_module()}} must return \code{reactive} \code{teal_data} object, it means that
both scenarios (1) and (2) are having the same effect for the reactivity of a \code{teal} application.
The difference is that in the first case the data is controlled from outside the app and in the
second case the data is controlled from custom module called inside of the app.

see \code{\link{validate_reactive_teal_data}} for more details.
}

\keyword{internal}
