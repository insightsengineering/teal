% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_nested_tabs.R
\name{module_nested_tabs}
\alias{module_nested_tabs}
\alias{ui_nested_tabs}
\alias{ui_nested_tabs.default}
\alias{ui_nested_tabs.teal_modules}
\alias{ui_nested_tabs.teal_module}
\alias{srv_nested_tabs}
\alias{srv_nested_tabs.default}
\alias{srv_nested_tabs.teal_modules}
\alias{srv_nested_tabs.teal_module}
\title{Create a \code{ui} of nested tabs of \code{teal_modules}}
\usage{
ui_nested_tabs(id, modules, datasets, depth = 0L, is_module_specific = FALSE)

\method{ui_nested_tabs}{default}(id, modules, datasets, depth = 0L, is_module_specific = FALSE)

\method{ui_nested_tabs}{teal_modules}(id, modules, datasets, depth = 0L, is_module_specific = FALSE)

\method{ui_nested_tabs}{teal_module}(id, modules, datasets, depth = 0L, is_module_specific = FALSE)

srv_nested_tabs(
  id,
  datasets,
  modules,
  is_module_specific = FALSE,
  reporter = teal.reporter::Reporter$new()
)

\method{srv_nested_tabs}{default}(
  id,
  datasets,
  modules,
  is_module_specific = FALSE,
  reporter = teal.reporter::Reporter$new()
)

\method{srv_nested_tabs}{teal_modules}(
  id,
  datasets,
  modules,
  is_module_specific = FALSE,
  reporter = teal.reporter::Reporter$new()
)

\method{srv_nested_tabs}{teal_module}(
  id,
  datasets,
  modules,
  is_module_specific = TRUE,
  reporter = teal.reporter::Reporter$new()
)
}
\arguments{
\item{id}{(\code{character(1)})\cr
module id}

\item{datasets}{(\verb{named list} of \code{FilteredData})\cr
object to store filter state and filtered datasets, shared across modules. For more
details see \code{\link[teal.slice:FilteredData]{teal.slice::FilteredData}}. Structure of the list must be the same as structure
of the \code{modules} argument and list names must correspond to the labels in \code{modules}.
When filter is not module-specific then list contains the same object in all elements.}

\item{depth}{(\code{integer(1)})\cr
number which helps to determine depth of the modules nesting.}

\item{is_module_specific}{(\code{logical(1)})\cr
flag determining if the filter panel is global or module-specific.
When set to \code{TRUE}, a filter panel is called inside of each module tab.}

\item{reporter}{(\code{Reporter}) object from \code{teal.reporter}}
}
\value{
depending on class of \code{modules}, \code{ui_nested_tabs} returns:
\itemize{
\item \code{teal_module}: instantiated \code{ui} of the module
\item \code{teal_modules}: \code{tabsetPanel} with each tab corresponding to recursively
calling this function on it.\cr
\code{srv_nested_tabs} returns a reactive which returns the active module that corresponds to the selected tab.
}
}
\description{
Create a \code{ui} of nested tabs of \code{teal_modules}
}
\section{\code{ui_nested_tabs}}{

Each \code{teal_modules} is translated to a \code{tabsetPanel} and each
of its children is another tab-module called recursively. The \code{ui} of a
\code{teal_module} is obtained by calling the \code{ui} function on it.

The \code{datasets} argument is required to resolve the \code{teal} arguments in an
isolated context (with respect to reactivity)
}

\section{\code{srv_nested_tabs}}{

This module calls recursively all elements of the \code{modules} returns one which
is currently active.
\itemize{
\item \code{teal_module} returns self as a active module.
\item \code{teal_modules} also returns module active within self which is determined by the \code{input$active_tab}.
}
}

\examples{
# use non-exported function from teal
example_modules <- getFromNamespace("example_modules", "teal")
example_datasets <- getFromNamespace("example_datasets", "teal")
include_teal_css_js <- getFromNamespace("include_teal_css_js", "teal")
ui_nested_tabs <- getFromNamespace("ui_nested_tabs", "teal")
srv_nested_tabs <- getFromNamespace("srv_nested_tabs", "teal")

mods <- example_modules()
datasets <- example_datasets()

ui <-function() {
  tagList(
    include_teal_css_js(),
    textOutput("info"),
    fluidPage( # needed for nice tabs
      ui_nested_tabs("dummy", modules = mods, datasets = datasets)
    )
  )
}
server <- function(input, output, session) {
  active_module <- srv_nested_tabs(
    "dummy",
    datasets = datasets,
    modules = mods
  )
  output$info <- renderText({
    paste0("The currently active tab name is ", active_module()$label)
  })
}
if (interactive()) {
  shinyApp(ui, server)
}

}
\keyword{internal}
