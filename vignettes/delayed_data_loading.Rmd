---
title: "Delayed Data Loading"
author: "Dawid Kałędkowski"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Delayed Data Loading}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, echo=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### Overview

Data plays an essential role in data analysis and `teal` provides several ways to
include datasets into shiny applications. Normally, one develops an application
in such a way that data are available before the app starts. This always involves
passing `data.frame` objects using the `cdisc_data` or `teal_data` functions to the teal application.
This way of building an app is applicable if data is physically available before
the call to `teal::init()`, so it can be obtained in pre-processing.
Including data to the shiny
app as [global objects](https://shiny.rstudio.com/articles/scoping.html) means
that they will be fixed and data won't change in time.
On the other hand data can be loaded by the shiny app itself and can request information from the app user such
as login, password, file location etc. before being loaded. Delayed data loading in teal application
involves specifying metadata which stores all information needed to pull the data
from the right source with appropriate arguments.
In delayed data loading application, before the main app loads a data loading screen is visible first.
This means that teal application can be

two-staged:

1. Data loading app
2. Main app

## Key definitions

Before we jump to creating application it is important to define a few terms
which are the key to understand new classes.

1. `Dataset` and `DatasetConnector` - `Dataset` is a class which contains physical
data in form of `data.frame` plus reproducible code. `DatasetConnector` is a
class which contains R call to obtain `Dataset`.

2. `data.frame`, `Dataset` and `Data`- object of class `Dataset` contains
a single `data.frame` object. `Data` is a collection of `Dataset` objects.

## Creating an app

### `Callable`

#### `CallableFunction`
This class won't be used often by the developers but it's essential for all
connectors to store and execute R function with possibility to get code to
reproduce function calls. In the example below and object of class `CallableFunction` is
created which runs `synthetic_cdisc_dataset` function with arguments set before.

```{r}
library(teal)
library(scda)

# initialize object
fun <- callable_function(fun = synthetic_cdisc_dataset)

# set arguments to function
fun$set_args(list(dataset_name = "adsl", name = "latest"))

# execute function with arguments set
df <- fun$run()
head(df)

# check reproducible code
cat(fun$get_call())
```

It's also possible to execute `fun$run()` function with arguments added on the fly
in a named `list`. Dynamic arguments won't be reflected in the reproducible code,
what will have a consequences in other places - we will get back to this in later
stages of the documentation.

```{r}
# add arguments on the fly
df <- fun$run(args = list(dataset_name = "adae", name = "latest"))
head(df)

# dynamic arguments not reflected in the call
cat(fun$get_call())
```

`CallableFunction` can also depend on other R objects as the example function below
depends on `ADSL`. The function can be executed in specific environment where we can
copy objects needed to execute call. To include object in the function call,
one has to use `$assign_to_env()` to copy object and
`$set_args(list(ADSL = as.symbol(ADSL)))` to link object with function argument.

```{r}
ADSL <- synthetic_cdisc_dataset(dataset_name = "adsl", name = "latest") # nolint

fun <- callable_function(fun = function(ADSL) { # nolint
  ADSL_2 <- ADSL # nolint
  ADSL_2$new_col <- TRUE
  ADSL_2
})

# copy ADSL to CallableFunction environment
fun$assign_to_env("ADSL", ADSL)

# set arguments
fun$set_args(args = list(ADSL = as.name("ADSL")))

# execute function
df <- fun$run()
head(df)

# get R code
fun$get_call()
```
### `CallableCode`

Simpler version of `Callable` class is `CallableCode`. Similarly to `CallableFunction`,
`CallableCode` stores some code which can be evaluated using `run()` but it
isn't able to use dynamic arguments to have the code more general. `CallableCode`
also allows the assignment of objects to an independent environment. `CallableCode` can
contain multiple lines code and also allows `library` calls.
Please note that objects assigned to this independent environment can't be modified
because they are locked immediately. This means that in `CallableCode` created
below it is not allowed to make any changes in `ADSL`.

```{r}
code <- callable_code(
  "ADTTE <- synthetic_cdisc_dataset(dataset_name = \"adtte\", name = \"latest\")
  ADTTE$x1 <- 1
  ADTTE <- dplyr::filter(ADTTE, PARAMCD %in% c('EFS', 'OS'))"
)

# examine call
cat(code$get_call())

# assign ADSL to environment
code$assign_to_env("ADSL", ADSL)

# evaluate call
df <- code$run()
head(df)
```

### `Dataset` (including `CDISCDataset`)

`Dataset` object is an R6 class which keeps a `data.frame` in its `raw_data` slot. One
can create a `Dataset` by including `data.frame` and setting data attributes. In
the example below we first create `adsl` and then put this `data.frame` into the
`cdisc_dataset` function. Together with `data.frame` one should always provide a
`dataname` and `code` to reproduce the data. For irreproducible apps `code`
can be omitted.

Note `cdisc_dataset` returns an object of `CDISCDataset` (inherited from `Dataset`) which
allows datasets to have parents and is needed for CDISC analysis.

```{r}
library(magrittr)

ADSL <- synthetic_cdisc_dataset(dataset_name = "adsl", name = "latest") %>% head(3) # nolint

adsl_dataset <- cdisc_dataset(dataname = "ADSL",
                      x = ADSL,
                      code = "ADSL <- synthetic_cdisc_dataset(dataset_name = \"adsl\", name = \"latest\") %>% head(3)"
)

```

The object created above contains all previously defined attributes which can be
extracted in any occasion.

```{r}
# check if code is reproducible
get_dataname(adsl_dataset)

# get label
get_dataset_label(adsl_dataset)

# get reproducible code
get_code(adsl_dataset)

# get data.frame
get_raw_data(adsl_dataset)

# get keys (i.e. the primary keys of the dataset)
adsl_dataset$get_keys()
```

### `DatasetConnector` (including `CDISCDatasetConnector`)

`DatasetConnector` contains `Callable` object to obtain a single dataset along
with other information such as keys, dataname, label and reproducible code. In
the code chunk below, connector is created basing on `synthetic_cdisc_dataset`
function

```{r}
adsl_conn <- dataset_connector(
  dataname = "ADSL",
  pull_callable = callable_function("synthetic_cdisc_dataset") %>%
    set_args(list(dataset_name = "adsl", name = "latest")),
  keys = get_cdisc_keys("ADSL"),
  label = "Subject-Level Analysis Dataset"
)
```

Initially, `adsl_conn` doesn't contain any data, but they can be loaded using
`load_dataset()` function. Before data loading, `adsl_conn` contains reproducible
code which is also an execution code to pull the data.

```{r}
# execution/reproducible code
get_code(adsl_conn)

# pull data
load_dataset(adsl_conn)

# get raw data
get_raw_data(adsl_conn)
```

`teal` also allows other variables to be passed to the connector which `Callable` object
can depend on. In the code below, one can add an `adsl`
object created above and `set_args` to `CallableFunction`. To properly link
`ADSL` argument several parameters have to match:
1. `dataname` of `adsl` should be `"ADSL"`
2. `vars = list(ADSL = adsl)` - `adsl` object should be passed to vars as a list
element with name `ADSL`.
3. Value of the `ADSL` argument in the `CallableFunction` has to be `as.name("ADSL")`.

```{r eval=TRUE}
# here we use the general dataset_connector function which pulls an object of type Dataset
# there is also a cdisc_dataset_connector function which pulls an object of type CDISCDataset
adsl_2 <- dataset_connector(
  dataname = "ADSL_2",
  pull_callable = callable_function(fun = function(ADSL) ADSL_2 <- ADSL) %>% # nolint
    set_args(list(ADSL = as.name("ADSL"))),
  keys = get_cdisc_keys("ADSL"),
  label = "Example label",
  vars = list(ADSL = ADSL)
)

load_dataset(adsl_2)
```

`DatasetConnector` like the other delayed data objects contains  a
`launch` method which can be used to obtain data using shiny application.
This function can be used to check if the objects are specified correctly and to
investigate potential mistakes. By default shiny app won't render any inputs for
datasets until we specify them. To set inputs we should use `$set_ui_input()`, by
passing ui module function, with `ns` argument (shiny namespaced ID object).

```{r eval=FALSE}
adsl_3 <- dataset_connector(
  dataname = "ADSL_3",
  pull_callable = callable_function(fun = function(ADSL, n) ADSL_3 <- head(ADSL, n)) %>% # nolint
    set_args(list(ADSL = as.name("ADSL"))),
  keys = get_cdisc_keys("ADSL"),
  label = "Example label",
  vars = list(ADSL = ADSL)
)

adsl_3$set_ui_input(function(ns) {
  list(
    numericInput(inputId = ns("n"), label = "Choose number of records", min = 0, value = 1)
  )
})

adsl_3$launch()
```

### `DataConnection`
Objects of this class are responsible to set connection with remote data sources.
`DataConnection` opens and closes connections by calling `CallableFunction` with
appropriate arguments. For example in a simplified version of `rice_connection`
below, a `DataConnection `uses `rice_session_open` and `rice_session_close`
functions.

```{r eval=FALSE}
if ("rice" %in% installed.packages()) {
  eval(parse(text = "library(rice)"))
}
open_fun <- callable_function("rice::rice_session_open")
close_fun <- callable_function("rice::rice_session_close")
close_fun$set_args(list(message = FALSE))

rice_conn <- teal:::DataConnection$new(
  open_fun = open_fun,
  close_fun = close_fun
)
```

One can open and close connection by using `rice_conn$open()` and `rice_conn$close()`
functions respectively. As in `DatasetConnector$pull()`, `open()` and `close()`
delegates function execution to `CallableFunction$run()`. Developers should use
`rice_conn$set_open_args()` to set some argument values to the reproducible call.
Arguments values set to the `CallableFunction` are saved persistently and will
be reflected when getting open code. Arguments passed to `rice_conn$open()` will
be used only to execute the function, but won't be returned in the code as they
are not stored anywhere. This feature is designed to hide some arguments from
being revealed in the code and can be intentional - for example, when using
personal passwords or other sensitive information. In code below `username` is
set (and stored) to the open function and `password` is a dynamic argument not
included in `rice_conn$get_open_call()` output.

```{r eval=FALSE}
# set open args
rice_conn$set_open_args(list(username = "your username"))

# open the rice connection
rice_conn$open(args = list(password = "your password"))

# check if open (open function evaluated successfully)
rice_conn$is_opened()

# check if open failed
rice_conn$is_open_failed()

# close
rice_conn$close()

# get reproducible call
rice_conn$get_open_call()
rice_conn$get_close_call()
```

In `shiny` application connection arguments needs to be linked with `inputs`,
that is why `DataConnection` contains a module. Developers can customize UI inputs to
open the connection using `set_open_ui()` and specify a relevant server function
using `set_open_server()`. It's important to keep in mind that the server module
needs a connection as a argument to `open()` and `close()` if needed.

```{r eval=FALSE}
rice_conn$set_open_ui(
  function(id) {
    ns <- NS(id)
    div(
      textInput(ns("username"), "Username"),
      passwordInput(ns("password"), "Password")
    )
  }
)

rice_conn$set_open_server(
  function(input, output, session, connection) {
    connection$open(args = list(username = input$username,
                                password = input$password),
                    try = TRUE)

    if (connection$is_open_failed()) {
      shinyjs::alert(
        paste("Error opening connection\nError message:", connection$get_open_error_message())
      )
    }
  }
)

rice_conn$launch()
```

### `RelationalDataConnector` (including `CDISCDataConnector`)

This class combines multiple `DatasetConnector` (or `CDISCDatasetConnector`) and a single `DataConnection` object.
It creates a module to manage connection and to load data. Below we create two
`DatasetConnector` objects and a `DataConnection` and we combine them
together in a `RelationalDataConnector` object.

```{r}
# create DatasetConnectors
adsl <- dataset_connector(
  dataname = "ADSL",
  pull_callable = callable_function("synthetic_cdisc_dataset") %>%
    set_args(list(dataset_name = "adsl", name = "latest")),
  keys = get_cdisc_keys("ADSL"),
  label = "Subject-Level Analysis Dataset"
)

adsl_3 <- dataset_connector(
  dataname = "ADSL_3",
  pull_callable = callable_function(fun = function(ADSL, name, n = 5) ADSL_3 <- head(ADSL, n)) %>% # nolint
    set_args(list(ADSL = as.name("ADSL"))),
  keys = get_cdisc_keys("ADSL"),
  label = "Example label",
  vars = list(ADSL = adsl)
)

adsl_3$set_ui_input(function(ns) {
  list(
    numericInput(inputId = ns("n"), label = "Choose number of records", min = 0, value = 1)
  )
})

connectors <- list(adsl, adsl_3)

# create connection
scda_open_fun <- callable_function(fun = library)
scda_open_fun$set_args(list(package = "scda"))
scda_conn <- teal:::DataConnection$new(open_fun = scda_open_fun) # nolint

# create DataConnector
data <- teal:::RelationalDataConnector$new(
  connection = scda_conn,
  connectors = connectors
)
```

The object created above can be used to pull data and obtain the code. It combines
code to pull the datasets preceded by any open connection code and followed by
any close connection code. Please note that `DataConnector` doesn't limit
what kind of connectors are set within, but one must be aware that it should
rather contain similar connectors (i.e. calling functions which share some arguments).
For example, if we execute `data$set_pull_args(args = list(name = "latest"))`, this
argument will be set for all connectors. In case when one connector contains
`CallableFunction` which doesn't have `seed` in its formals then it will fail.
`CallableCode` can't hold any additional arguments as it's fixed and it will
ignore every arguments set with `set_pull_args`.

```{r}
cat(get_code(data))

#pull ADSL and ADSL_3
data$set_pull_args(args = list(name = "latest"))
data$pull()
```

By default `RelationalDataConnector` creates simple shiny module without any
inputs for connectors and datasets. This means that connection opening/closing
and pulling datasets are done on default arguments. However, users can easily
extend the module using `set_ui()` and `set_server()` to specify
the UI and server function themselves. The general rule for creating these modules is that callback
from server to UI is not possible, because server module is executed after the submit
button is clicked. Although see `set_preopen_server` of `DataConnection` object for a slight
relaxation of this rule.
Below we extend the app interface by adding a text input which will be passed to the
`scda` function. The UI is created from `scda_conn` and
`connectors` object while the server module requires `connectors` and `connection`
objects as additional arguments.


```{r}
data$set_ui(
  function(id, ...) {
    ns <- NS(id)
    tagList(
      scda_conn$get_open_ui(ns("open_connection")),
      textInput(ns("name"), p("Choose", code("name")), value = "latest"),
      do.call(
        what = "tagList",
        args = lapply(
          connectors,
          function(connector) {
            div(
              connector$get_ui(
                id = ns(connector$get_dataname())
              ),
              br()
            )
          }
        )
      )
    )
  }
)

data$set_server(
  function(input, output, session, connection, connectors) {
    # opens connection
    if (!is.null(connection$get_open_server())) {
      callModule(connection$get_open_server(),
                 id = "open_connection",
                 connection = connection)
    }

    for (connector in connectors) {
      # set_args before to return them in the code (fixed args)
      set_args(connector, args = list(name = input$name))

      # pull each dataset
      callModule(connector$get_server(), id = connector$get_dataname())
      if (connector$is_failed()) {
        break
      }
    }
  }
)
```

Executing `data$launch()` will open shiny application. Remember that data can be
loaded only once, in case you run above code please reinitialize datasets,
connection and data object again.

```{r eval=FALSE}
# if datasets have been pulled already
#  - reinitialize datasets and data object again
data$launch()
```

### `RelationalData` (including `CDISCData`)

 `RelationalData` manages `Dataset`, `DatasetConnector` and `RelationalDataConnector`
objects. `CDISCData` is the equivalent object when creating apps to analyse CDISC data.
These objects are created using `teal_data` and `cdisc_data` respectively and these
objects are passed as the `data` argument into `teal::init`.


```{r}
data <- cdisc_data(
  cdisc_dataset(dataname = "ADSL",
    synthetic_cdisc_dataset(dataset_name = "adsl", name = "latest"),
    code = "ADSL <- synthetic_cdisc_dataset(dataset_name = \"adsl\", name = \"latest\")"
  ),
  cdisc_dataset(dataname = "ADTTE",
    synthetic_cdisc_dataset(dataset_name = "adtte", name = "latest"),
    code = "ADTTE <- synthetic_cdisc_dataset(dataset_name = \"adtte\", name = \"latest\")"
  )
)
```

One can combine multiple delayed data objects using `[teal|cdisc]_data` functions and
include them in a shiny application. `RelationalData` gathers all objects and sets
combined UI with shiny inputs from all objects.
In the code chunk below we specified four dataset connectors but
developers can include any number and any type of objects.

```{r}
adsl <- scda_cdisc_dataset_connector("ADSL", "adsl")
adae <- scda_cdisc_dataset_connector("ADAE", "adae")
advs <- scda_cdisc_dataset_connector("ADVS", "advs")
adtte <- scda_cdisc_dataset_connector("ADTTE", "adtte")

data <- cdisc_data(adsl, adae, advs, adtte)
```

Similar to other connectors one can use `launch()` method to investigate if data is set
correctly. Unlike the other connectors, this class lacks `pull()` method.

```{r eval=FALSE}
data$launch()
```

Reproducible code attached to the `data` object is a combined code of all components,
but one can also extract code from single dataset by specifying `dataname` argument.

```{r}
get_code(data)
get_code(data, dataname = "ADSL")
get_code(data, dataname = "ADTTE")
```

Developers can also extract datasets and connectors included in the `RelationalData`.

```{r, eval=FALSE}
# get loaded datasets
data$get_datasets()

# get single dataset
data$get_dataset(dataname = "ADSL")

# get data and dataset connectors
data$get_connectors()

# get all datasets/connectors
data$get_items()
```

### Data modification

Since delayed data objects are just metadata before data is loaded there are
dedicated functions to allow dataset mutations. To modify a single dataset one
should use `mutate_dataset` by specifying `code` argument with code as a single
character or `script` with location of the script file.

```{r}
adsl <- cdisc_dataset(
  dataname = "ADSL",
  synthetic_cdisc_dataset(dataset_name = "adsl", name = "latest"),
  code = "ADSL <- synthetic_cdisc_dataset(dataset_name = \"adsl\", name = \"latest\")"
) %>%
  mutate_dataset(code = "ADSL$x1 <- 1")


adtte <- scda_cdisc_dataset_connector(
  dataname = "ADTTE", "adtte") %>%
  mutate_dataset(code = "ADTTE$x2 <- 2")
```

`get_code()` function returns loading code from `CallableFunction` and mutation
code as provided in using `mutate_dataset`.

```{r}
cat(get_code(adsl))
cat(get_code(adtte))
```

`mutate_dataset` can also be used on `RelationalData` objects which applies
the `code` to the dataset specified in `dataname`. This is important, as `RelationalData`
can track each call which affects this particular dataset. Check the code below,
where we create data containing two datasets using the `cdisc_data` function.
We can still use `mutate_dataset` on the object which contains multiple datasets,
with one requirement - one needs to specify `dataname`. Afterwards, one can
extract reproducible code from data which affects this particular `dataname`.

```{r}
data <- cdisc_data(adsl, adtte) %>%
  mutate_dataset(code = "ADSL$x3 <- 3", dataname = "ADSL")

# get reproducible code of all datasets
cat(get_code(data))

# get ADSL reproducible code
cat(get_code(data, dataname = "ADSL"))
```

One can also combine multiple `mutate_dataset` calls applied interchangeably to
all datasets.

```{r}
data <- mutate_dataset(data, code = "ADTTE$x4 <- 4", dataname = "ADTTE") %>%
  mutate_dataset(code = "ADSL <- dplyr::filter(ADSL, SEX == 'F')", dataname = "ADSL")

cat(get_code(data, "ADSL"))
cat(get_code(data, "ADTTE"))
```

Sometimes code of one object can depend on another, in this case we can link
them in the same way how we link `DatasetConnector` objects. If object code
is dependent on another, as ADTTE depends on ADSL below, `get_code`
will return everything we need to be executed to reproduce this dataset.

```{r}
data <- mutate_dataset(
  data,
  code = "ADTTE <- filter(ADTTE, USUBJID %in% ADSL$USUBJID)",
  dataname = "ADTTE",
  vars = list(ADSL = adsl) # vars = list(<DATANAME> = <dataset name>))
) %>%
  mutate_dataset("ADSL$var_created_after <- NA", dataname = "ADSL")


cat(get_code(data, dataname = "ADTTE"))
```

Using `mutate_dataset` creates a tree of calls, which can be easily
subset by `dataname`, but developers can also use `mutate_data` function which
doesn't require `dataname` to be specified. When `mutate_data` is used, code for
a single dataset is not possible to be subset, instead code of all datasets is
returned.

```{r}
data <- mutate_data(data,
  code = "
    ADSL$x3 <- 3
    proxy_var <- 4
    ADTTE$x4 <- proxy_var
  "
)

# single dataset code is not possible to obtain anymore
cat(get_code(data, "ADSL"))
```

### Delayed choices

`teal` applications which initialize using data consisting only of pre-existing datasets
have all data accessible when pre-processing for the app. Getting column names, factor
levels or numeric variables ranges are possible before the app starts. It means
that the developer can explicitly specify `data_extract_spec`, `choices_selected`
and their components. The `teal` package also supports these functions for
delayed data loading, but the way to use them differs slightly.
In the code block below, the default version of `variable_choices` is presented
where the function uses an `ADSL` object containing "physical" data.

```{r}
adsl_data <- synthetic_cdisc_data("latest")$adsl
variable_choices(data = adsl_data)
```

An alternative option is to put a dataname into `data` argument, which will result
in creating a `delayed_variable_choices` object. The developer can always
explicitly specify a `subset` of column names regardless of the class of the `data`.

```{r}
variable_choices(data = "ADSL", subset = c("AVAL", "BMRKR1"))
```

If the dataset is not known before, one can use a function which subsets
column names from data. This function will be executed after the data is
pulled.

```{r}
get_continuous <- function(data) {
  idx <- vapply(data, function(x) is.numeric(x) && length(unique(x)) > 6, logical(1))
  colnames(data)[idx]
}

variable_choices(data = "ADSL", subset = get_continuous)
```

Another function which can be used with the delayed data loading is
`value_choices`, which defines choices from levels of one or multiple variables.
By default `value_choices` uses a `data.frame` from the `data` argument and
choices will be immediately constructed from this object.

```{r}
ADTTE <- synthetic_cdisc_data("latest")$adtte # nolint
value_choices(
  data = ADTTE,
  var_choices = "PARAMCD",
  var_label = "PARAM",
  subset = levels(ADTTE$PARAMCD)[1:2]
)
```

Similar to `variable_choices`, developers can specify the `data` argument with
data name (`"ADTTE"`) and use a function to `subset` choices. The `subset` function
will be executed after data is pulled.

```{r}
value_choices(
  data = "ADTTE",
  var_choices = "PARAMCD",
  var_label = "PARAM",
  subset = function(data) levels(data$PARAMCD)[1:2]
)
```

`variable_choices` and `value_choices` can be used with `choices_selected`,
`select_spec` or `filter_spec` to properly declare data extracts.

```{r}
adsl <- scda_cdisc_dataset_connector("ADSL", "adsl")
adrs <- scda_cdisc_dataset_connector("ADRS", "adrs")


get_continuous <- function(data) {
  idx <- vapply(data, function(x) is.numeric(x) && length(unique(x)) > 6, logical(1))
  colnames(data)[idx]
}

data_extract_x <- data_extract_spec(
  dataname = "ADSL",
  select = select_spec(
    choices = variable_choices("ADSL", subset = get_continuous)
  ),
  filter = filter_spec(
    label = "Select endpoints:",
    vars = "ARMCD", #variable_choices("ADSL", "ARMCD") # nolint
    choices = value_choices("ADSL",
                            var_choices = "ARMCD",
                            var_label = "ARM",
                            subset = function(data) unique(as.character(data$ARMCD))),
    selected = "ARM A",
    multiple = TRUE
  )
)

data_extract_y <- data_extract_spec(
  dataname = "ADRS",
  select = select_spec(
    choices = variable_choices("ADRS", subset = get_continuous)
  ),
  filter = filter_spec(
    label = "Select endpoints:",
    vars = c("PARAMCD", "AVISIT"),
    choices = value_choices(
      data = "ADRS",
      var_choices = c("PARAMCD", "AVISIT"),
      var_label = c("PARAMCD", "AVISIT"),
      subset = function(data) {
        unique(
          paste(
            data$PARAMCD,
            data$AVISIT,
            sep = " - "
          )
        )
      }),
    multiple = TRUE
  )
)
```

The `delayed_data_extract_spec` objects created above can be included in
teal modules to create an application.

```{r, eval=FALSE}
library(ggplot2)
app <- init(
  data = teal_data(adsl, adrs),
  modules = root_modules(
    teal.modules.general::tm_g_bivariate(
      x = data_extract_x,
      y = data_extract_y,
      use_density = FALSE,
      plot_height = c(600L, 200L, 2000L),
      ggtheme = "gray"
    )
  )
)

shinyApp(app$ui, app$server)
```
