---
title: "Data Transformations as Shiny Module"
author: "NEST CoreDev"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Data Transformations as shiny Module}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

`teal` version `0.16` introduced a new, optional argument in `teal::module`, `transformators`.
This argument accepts a `list` of `teal_transform_module` objects, which are a special class of `teal_data_module` created using the `teal_transform_module()` function.

A `teal_transform_module` is a `shiny` module that takes `ui` and `server` arguments, and that encodes data transformations.
When provided, `teal` will execute data transformations for the specified module when it is loaded and whenever the original data changes.
The transformations are applied to the data _before_ it reaches the module.
The `ui` elements of the transform module will be added to the filter panel, while the server function provides the data manipulation logic.

This vignette describes how to manage custom data transformations in `teal` apps.

## Creating a data transformation module

Let's initialize a simple `teal` app by providing `iris` and `mtcars` as input datasets.

```{r message = FALSE, warning = FALSE}
library(teal)

data <- within(teal_data(), {
  iris <- iris
  mtcars <- mtcars
})

app <- init(
  data = data,
  modules = teal::example_module()
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

### Single transformator

Let us create a simple `teal_transform_module` that returns the first `n` number of rows of `iris` based on the user input.

We will achieve this by creating the `ui` with a `numericInput` for the user to specify the number of rows to be displayed.
The `server` function will take a reactive expression holding `data` as argument and return a reactive expression holding transformed `data`.

```{r}
data <- within(teal_data(), {
  iris <- iris
  mtcars <- mtcars
})

transformator_iris <- teal_transform_module(
  label = "Custom transformator for iris",
  ui = function(id) {
    ns <- NS(id)
    tags$div(
      numericInput(ns("n_rows"), "Number of rows to display", value = 6, min = 1, max = 150, step = 1)
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        within(
          data(),
          iris <- head(iris, num_rows),
          num_rows = input$n_rows
        )
      })
    })
  }
)

app <- init(
  data = data,
  modules = teal::example_module(transformators = list(transformator_iris))
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

_Note_: The `server` function of a `teal_transform_module` must return a reactive expression with a `teal_data` obect.
In order to maintain full reactivity, we recommended using `reactive()` over `eventReactive()`.
If you do use `eventReactive()` or `bindEvent()`, the trigger event should include `data()` _(e.g. `eventReactive(list(input$a, data()), {...})`)_.
See [this discussion](https://github.com/insightsengineering/teal/issues/1303#issuecomment-2286239832) for a detaileed explanation.

### Multiple transformators

`module(transformators)` accepts a list so we can use multiple `teal_transform_module`s at the same time.

Let us add another transformation that creates a column with `rownames` in `mtcars`.
Note that this module does not have interactive UI elements.

```{r}
data <- within(teal_data(), {
  iris <- iris
  mtcars <- mtcars
})

transformator_iris <- teal_transform_module(
  label = "Custom transformator for iris",
  ui = function(id) {
    ns <- NS(id)
    tags$div(
      numericInput(ns("n_rows"), "Number of rows to subset", value = 6, min = 1, max = 150, step = 1)
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        within(
          data(),
          iris <- head(iris, num_rows),
          num_rows = input$n_rows
        )
      })
    })
  }
)

transformator_mtcars <- teal_transform_module(
  label = "Custom transformator for mtcars",
  ui = function(id) {
    ns <- NS(id)
    tags$div(
      "Adding rownames column to mtcars"
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        within(data(), {
          mtcars$rownames <- rownames(mtcars)
          rownames(mtcars) <- NULL
        })
      })
    })
  }
)

my_transformators <- list(
  transformator_iris,
  transformator_mtcars
)

app <- init(
  data = data,
  modules = teal::example_module(transformators = my_transformators)
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

Note that it is possible to pass two transformator modules act on one dataset.
In such cases, transformations will follow the order of the transformators.

```{r}
transformator_iris_scale <- teal_transform_module(
  label = "Scaling transformator for iris",
  ui = function(id) {
    ns <- NS(id)
    uiOutput(ns("scaled_columns_container"))
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      ns <- session$ns

      scalable_columns <- names(Filter(is.numeric, data()[["iris"]])) |> isolate()

      output$scaled_columns_container <- renderUI({
        selectInput(
          inputId = ns("scaled_columns"),
          label = "Columns to scale",
          choices = scalable_columns,
          selected = input$scaled_columns,
          multiple = TRUE
        )
      })

      reactive({
        within(
          data(),
          {
            iris[scaled_columns] <- scale(iris[scaled_columns])
          },
          scaled_columns = input$scaled_columns
        )
      })
    })
  }
)

my_transformators <- list(
  transformator_iris,
  transformator_iris_scale,
  transformator_mtcars
)

app <- init(
  data = data,
  modules = teal::example_module(transformators = my_transformators)
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

By using multiple transformators, we can apply different transformations to different datasets available in the `teal_data` object.

In this example, one transformator enables users to subset the `iris` dataset interactively, while another automatically adds row names as a new column in the `mtcars` dataset.

This approach provides greater flexibility in data preprocessing, allowing transformations to be tailored to specific datasets for a specific module.
