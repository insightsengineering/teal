---
title: "Including Data in teal Applications"
author: "NEST CoreDev"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    toc: true
    toc_depth: 5
    number_sections: false
vignette: >
  %\VignetteIndexEntry{Including Data in teal Applications}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Data in `teal` Applications

While the `teal` framework is mainly geared towards clinical data that conforms to the `ADaM` standard, general, non-relational data is handled just as well and the mechanism of passing data to applications is virtually the same.
Also, modules in `teal.modules.general` have been designed to work with general data.

All applications use the `teal_data` class as a data container.
`teal_data` objects are passed to `init` to build the application, where modified by the filter panel (if applicable) and passed on to modules.
Thus, the first step of building `teal` app is creating a `teal_data` object.

### General Data

A `teal_data` object is creating the `teal_data` function and passing data objects as `name:value` pairs.

```{r, message=FALSE}
library(teal)

# create data objects
IRIS <- iris
CARS <- mtcars

# create teal_data
data <- teal_data(IRIS = IRIS, CARS = CARS)
```

Note that `IRIS` and `CARS` have been added to the `datanames` property of `data` (jump to [`teal_data` properties]).

This is sufficient to run a `teal` app.

```{r}
# build app
app <- init(
  data = data,
  modules = example_module()
)

# run app
if (interactive()) shinyApp(app$ui, app$server)
```

### ADaM Data

The container used for `CDISC` data is the `cdisc_data` class, which is an extension of `teal_data` created with the `cdisc_data` function.
The `ADaM` data model allows us to take some short cuts when creating the object.
For example, relationships between datasets are known and so in most cases default join keys can be set (jump to [`teal_data` properties]).
See the documentation for `cdisc_data` for details.

In the example below, two standard `CDISC` datasets (`ADSL` and `ADTTE`) are passed to `cdisc_data`.

```{r}
adsl <- data.frame(
  STUDYID = "study",
  USUBJID = 1:10,
  SEX = sample(c("F", "M"), 10, replace = TRUE),
  AGE = rpois(10, 40)
)
adtte <- rbind(adsl, adsl, adsl)
adtte$PARAMCD <- rep(c("OS", "EFS", "PFS"), each = 10)
adtte$AVAL <- c(
  rnorm(10, mean = 700, sd = 200), # dummy OS level
  rnorm(10, mean = 400, sd = 100), # dummy EFS level
  rnorm(10, mean = 450, sd = 200) # dummy PFS level
)

data_cdisc <- cdisc_data(ADSL = adsl, ADTTE = adtte)

datanames(data_cdisc)
join_keys(data_cdisc)
```


```{r}
app <- init(
  data = data_cdisc,
  modules = example_module()
)

shinyApp(app$ui, app$server)
```

### MultiAssayExperiment Data

The `MultiAssayExperiment` package offers a data structure for representing and analyzing multi-omics experiments: a biological analysis approach utilizing multiple types of observations, such as DNA mutations and abundance of RNA and proteins, in the same biological specimens.

The `MultiAssayExperiment` class is described in detail [here](https://www.bioconductor.org/packages/release/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html).


```{r, eval=FALSE}
library(MultiAssayExperiment)
utils::data(miniACC)

data_mae <- teal_data(MAE = miniACC)

app <- init(
  data = data_mae,
  modules = example_module()
)

shinyApp(app$ui, app$server)
```

The filter panel supports `MAE` data out of the box, but `teal` itself does not guarantee that any module will work with `MAE` data the same way it works with other types of data (e.g. `ADaM`) because `MAE` has a unique structure that requires special consideration when developing a module.
The package [`teal.modules.hermes`](https://insightsengineering.github.io/teal.modules.hermes/latest-tag/) has been developed specifically with `MAE` in mind and will be more reliable.

### Delayed Data

The one departure from passing a `teal_data` object to `init` is when the data does not exist in the environment where the app is run, e.g. when it has to be pulled from a remote source.
In those cases a `teal_data_module` must be used.
See [this vignette](https://insightsengineering.github.io/teal/latest-tag/articles/data-as-shiny-module.html) for a detailed description.

## Creating Data by Evaluating Code

A `teal_data` stores data in a separate environment.
Therefore, modifying the stored datasets requires that code be evaluated in that environment.
Following that logic, one can create an empty `teal_data` object and populate it by evaluating code.
This can be done using the `eval_code` function or, more conveniently, using the `within` function.

```{r}
data <- teal_data(IRIS = iris)
data0 <- teal_data()
data1 <- teal.code::eval_code(data0, "IRIS <- iris")
data2 <- within(data0, IRIS <- iris)
```

The primary difference between `eval_code` and `within` is that the former accepts code as character vector or language objects (calls and expressions), while `within` accepts _only_ inline code. See `?eval_code` for more details.

The ability to pass code as character vector to `eval_code` opens the door to using code stored in a file.
```{r, eval=FALSE}
# not run
data_from_file <- teal_data()
data_from_file <- eval_code(data, readLines("<path_to_file>"))
```

## Passing Data And Code

`teal_data` can also be created by passing existing objects and supplying the code that was used to create them.

```{r}
data_with_objects_and_code <- teal_data(IRIS = iris, code = "IRIS <- iris")
```

As with `eval_code`, `code` can also be taken from a file.

```{r, eval=FALSE}
# not run
data_with_objects_and_code <- teal_data(IRIS = iris, code = readLines("<path_to_file>"))
```

## `teal_data` properties

##### `datanames`

The `datanames` property lists the objects stored in the `teal_data` objects that constitute datasets of interest.
Objects passed to `teal_data` become automatically listed in the `datanames` property of the resulting object.
Objects created in `teal_data` by evaluating code need not be data objects of interest and as such they are not automatically added to `datanames`.
Use the `datanames` function to modify the `datanames` property.

```{r}
data_with_objects <- teal_data(IRIS = IRIS, CARS = CARS)
data_with_code <- within(teal_data(), IRIS <- iris)
datanames(data_with_objects)
datanames(data_with_code)
datanames(data_with_code) <- "IRIS"
datanames(data_with_code)
```

All `teal` modules take a `datanames` argument that determines which datasets they are to have access to.
Only objects enumerated in the `datanames` property of the `teal_data` object can be used.

For a detailed explanation of datanames, see [this `teal.data` vignette](https://insightsengineering.github.io/teal.data/latest-tag/articles/teal-data.html)

(back to [General Data])

##### `join_keys`

Using relational data requires specifying joining keys for each pair of datasets.
Primary keys are unique row identifiers in individual datasets and thus should to be specified for each dataset.
Foreign keys describe mapping of variables between datasets.
Joining keys are stored in the `join_keys` property, which can be set when creating a `teal_data` object, using the `join_keys` argument, or using the `join_keys` function.

```{r}
ds1 <- data.frame(
  id = seq(1, 10),
  group = rep(c("A", "B"), each = 5)
)
ds2 <- data.frame(
  group = c("A", "B"),
  condition = c("condition1", "condition2")
)
keys <- join_keys(
  join_key("DS1", keys = "id"),
  join_key("DS2", keys = "group"),
  join_key("DS1", "DS2", keys = c("group" = "group"))
)
data_relational1 <- teal_data(DS1 = ds1, DS2 = ds2, join_keys = keys)
data_relational2 <- teal_data(DS1 = ds1, DS2 = ds2)
join_keys(data_relational2) <- keys
```

For a detailed explanation of join keys, see [this `teal.data` vignette](https://insightsengineering.github.io/teal.data/latest-tag/articles/join-keys.html).

(back to [ADaM Data])

##### `verified`

`teal_data` allows for tracking code from data creation through filtering through analysis so that the whole process can be reproduced.
The `verified` designates whether or not reproducibility has been confirmed.
`teal_data` objects that are created empty and are only modified by evaluating code in them are verified by default.
Objects created with data objects and code are not verified by default but can become verified by running the `verify` function.

```{r}
data_with_code
data_with_objects_and_code
data_with_objects_and_code_verified <- verify(data_with_objects_and_code)
data_with_objects_and_code_verified
```


For a detailed explanation of verification, see [this `teal.data` vignette](https://insightsengineering.github.io/teal.data/latest-tag/articles/teal-data.html).

(back to [Passing Data And Code])



## Further Reading

For more information about preprocessing, relational data, reproducibility, and more, please refer to the [`teal.data` package](https://insightsengineering.github.io/teal.data/latest-tag/).
