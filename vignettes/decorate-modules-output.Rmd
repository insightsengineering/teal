---
title: "Decorate modules output"
author: "NEST CoreDev"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Decorate modules output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Create a decoration object

`teal_transform_module` without `ui`. Nothing will be displayed, only server code will be executed.

    ```{r}
static_decorator <- teal_transform_module(
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        req(data())
        data() |> within({
          plot <- plot +
            ggtitle("This is title") +
            xlab("x axis")
        })
      })
    })
  }
)
    ```


Using language will result in `teal_transform_module` without `ui`.

    ```{r}
static_decorator_lang <- quote(plot <- plot +
  ggtitle("This is title") +
  xlab("x axis title"))
    ```


Adding interactivity requires creating a proper shiny module.
    ```{r}
interactive_decorator <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      textInput(ns("x_axis_title"), "X axis title", value = "x axis")
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        req(data())
        data() |> within(
          {
            plot <- plot +
              ggtitle("This is title") +
              xlab(x_axis_title)
          },
          x_axis_title = input$x_axis_title
        )
      })
    })
  }
)
    ```


Thanks to the function-constructor app developer doesn't need to know what is the object name inside of the module's 
`server`. One can create any single argument function. Mapping `x` -> `plot` happens in `decorate_teal_data` and 
requires to specify `output_name = "plot"` (modules' developer duty).

```{r}
fun_decorator <- function(x) {
  x <- x + ggtitle("This is title") + xlab("x_axis_title")
}
```

Failures in decorators are handled by internal `teal` mechanism called `trigger_on_success`, which will never 
break `data` object inside of the module. Instead decorator will be ignored and relevant error message will be shown.

    ```{r}
failing_decorator <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      textInput(ns("x_axis_title"), "X axis title", value = "x axis")
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive(stop("Hihi"))
    })
  }
)
    ```

## Example module

To include decorator to the `teal_module` one needs to add an extra argument to the module-constructor function `tm_`.
Decorator passed to the constructor needs to go through `decorate_teal_data()` in order to cast `language`  or `function` object into `teal_transform_module`. _`decorate_teal_data()` wouldn't be necessary if an app developer 
always provides `teal_transform_module`. We could extend `teal_transform_module()` constructor by `expr` argument instead but using `function` would be impossible then._

Decorators should be passed via `ui_args` and `server_args` to the module's `ui` and `server`, where they should be 
consumed by `ui/srv_transform_data`.


```{r}
library(ggplot2)
tm_decorated_plot <- function(label = "module", decorator = teal_transform_module()) {
  decorator_obj <- decorate_teal_data(x = decorator, output_name = "plot")

  module(
    label = label,
    ui = function(id, decorator) {
      ns <- NS(id)
      div(
        selectInput(ns("dataname"), label = "select dataname", choices = NULL),
        selectInput(ns("x"), label = "select x", choices = NULL),
        selectInput(ns("y"), label = "select y", choices = NULL),
        ui_transform_data(ns("decorate"), transforms = decorator),
        plotOutput(ns("plot")),
        verbatimTextOutput(ns("text"))
      )
    },
    server = function(id, data, decorator) {
      moduleServer(id, function(input, output, session) {
        observeEvent(data(), {
          updateSelectInput(inputId = "dataname", choices = teal.data::datanames(data()))
        })

        observeEvent(input$dataname, {
          updateSelectInput(inputId = "x", choices = colnames(data()[[input$dataname]]))
          updateSelectInput(inputId = "y", label = "select y", choices = colnames(data()[[input$dataname]]))
        })

        q1 <- reactive({
          req(input$dataname, input$x, input$y)
          data() |>
            within(
              {
                plot <- ggplot2::ggplot(dataname, ggplot2::aes(x = x, y = y)) +
                  ggplot2::geom_point()
              },
              dataname = as.name(input$dataname),
              x = as.name(input$x),
              y = as.name(input$y)
            )
        })

        q2 <- srv_transform_data("decorate", data = q1, transforms = decorator)

        plot_r <- reactive({
          req(q2())
          q2()[["plot"]]
        })

        output$plot <- renderPlot(plot_r())
        output$text <- renderText({
          teal.code::get_code(q2())
        })
      })
    },
    ui_args = list(decorator = decorator_obj),
    server_args = list(decorator = decorator_obj)
  )
}
```

## Example app

```{r}
app <- init(
  data = teal_data(iris = iris, mtcars = mtcars),
  modules = modules(
    tm_decorated_plot("identity"),
    tm_decorated_plot("no-ui", decorator = static_decorator),
    tm_decorated_plot("lang", decorator = static_decorator_lang),
    tm_decorated_plot("fun", decorator = fun_decorator),
    tm_decorated_plot("interactive", decorator = interactive_decorator),
    tm_decorated_plot("failing", decorator = failing_decorator)
  )
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

## To improve

- Error handling when a decorator throws an error.
- Rewrite modules so that they always have a graph as `graph` (or `plot`, `g`, `p` etc.) and table as 
  `table` (or `t` etc.) and listings as `listings` (or `l` etc.). This simplifies/standardizes a construction of
  `teal_transform_module` which can be re-used in multiple modules. 