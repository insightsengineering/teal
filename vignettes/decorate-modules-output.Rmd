---
title: "Customizing Module Output"
author: "NEST CoreDev"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Customizing Module Output}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

`teal` is a powerful `shiny`-based framework with built-in modules for interactive data analysis. 
This document outlines the customization options available for modifying the output of `teal` modules. 
You will learn how to use `teal_transform_module` to modify and enhance the objects created by `teal` modules, 
enabling you to tailor the outputs to your specific requirements without rewriting the original module code.

Adjusting input data or customizing module outputs in `teal` is accomplished using `transforms` created through 
`teal_transform_module`. This document will focus on modifying outputs, and for clarity, we will refer to these 
output-modifying objects as decoration objects or decorators.

Throughout the examples, you will see references to a `data()` object. 
This reactive object, built with [`teal_data()`](https://insightsengineering.github.io/teal.data/latest-tag/articles/teal-data.html),
holds all the data used `within` the module as well as the generated output objects. 
`teal_transform_module` operates on this object and can execute custom R code within the `data()` environment using the `within function`. 
This approach allows you to pass code directly and evaluate it in the `data()` environment.

## Decorators

### Server

The simplest way to create a decorator is to use `teal_transform_module` without specifying a `ui`.
This approach adds functionality solely to the server code of the `teal` app. 
In the following example, we assume that the module contains an object (of class `ggplot2`) named `plot`. 
We modify the title and x-axis label of plot:

```{r}
library(teal)
static_decorator <- teal_transform_module(
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        req(data())
        within(data(), {
          plot <- plot +
            ggtitle("This is title") +
            xlab("x axis")
        })
      })
    })
  }
)
```

To simplify the repetitive elements of writing new decorators 
(e.g., `function(id, data), moduleServer, reactive, within(data, ...)`), 
you can use the `make_teal_transform_server(expr)` wrapper, which takes an `expression` as input:

```{r}
static_decorator_lang <- teal_transform_module(
  server = make_teal_transform_server(
    expression(
      plot <- plot +
        ggtitle("This is title") +
        xlab("x axis title")
    )
  )
)
```

### UI

To create a decorator with user interactivity, you can incorporate a `shiny` UI module. 
In the example below, the x-axis title is set dynamically via a `textInput`, allowing users to specify their preferred label. 
Note how the input parameters are passed to the `within` function (e.g., `x_axis_title`):

```{r}
interactive_decorator <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      textInput(ns("x_axis_title"), "X axis title", value = "x axis")
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        req(data())
        within(data(),
          {
            plot <- plot +
              ggtitle("This is title") +
              xlab(x_axis_title)
          },
          x_axis_title = input$x_axis_title
        )
      })
    })
  }
)
```

As in the earlier examples, `make_teal_transform_server(expr)` can simplify the creation of the server component. 
This wrapper allows you to use `input` object names directly in the expression:

```{r}
interactive_decorator_lang <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      textInput(ns("x_axis_title"), "X axis title", value = "x axis")
    )
  },
  server = make_teal_transform_server(
    expression(
      plot <- plot +
        ggtitle("This is title") +
        xlab(x_axis_title)
    )
  )
)
```

## Handling Various Object Names

`teal_transform_module` relies on the names of objects created within a module. 
Writing a decorator that applies to any module can be challenging because different modules may use different object names.
It is recommended to create a library of decorator functions that can be adapted to the specific object names used in `teal` modules.
In the following example, focus on the `output_name` parameter to see how decorator can be applied to multiple modules:

```{r}
gg_xlab_decorator <- function(output_name) {
  teal_transform_module(
    ui = function(id) {
      ns <- NS(id)
      div(
        textInput(ns("x_axis_title"), "X axis title", value = "x axis")
      )
    },
    server = function(id, data) {
      moduleServer(id, function(input, output, session) {
        reactive({
          req(data())
          within(data(),
            {
              output_name <- output_name +
                xlab(x_axis_title)
            },
            x_axis_title = input$x_axis_title,
            output_name = as.name(output_name)
          )
        })
      })
    }
  )
}
```

Decorator failures are managed by an internal `teal` mechanism called `trigger_on_success`, which ensures that the `data`
object within the module remains intact. If a decorator fails, it will be ignored, and an appropriate error message will be displayed.

```{r}
failing_decorator <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      textInput(ns("x_axis_title"), "X axis title", value = "x axis")
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive(stop("This is error"))
    })
  }
)
```

## Decorating Plots

### Example Module

To include decorators in a `teal` module, pass them as arguments (`ui_args` and `server_args`) to the moduleâ€™s `ui` and 
`server` components, where they will be used by `ui/srv_teal_transform_module`:


```{r}
tm_decorated_plot <- function(label = "module", transforms = list(), decorators = teal_transform_module()) {
  module(
    label = label,
    ui = function(id, decorators) {
      ns <- NS(id)
      div(
        selectInput(ns("dataname"), label = "select dataname", choices = NULL),
        selectInput(ns("x"), label = "select x", choices = NULL),
        selectInput(ns("y"), label = "select y", choices = NULL),
        ui_teal_transform_data(ns("decorate"), transforms = decorators),
        plotOutput(ns("plot")),
        verbatimTextOutput(ns("text"))
      )
    },
    server = function(id, data, decorators) {
      moduleServer(id, function(input, output, session) {
        observeEvent(data(), {
          updateSelectInput(inputId = "dataname", choices = names(data()))
        })

        observeEvent(input$dataname, {
          req(input$dataname)
          updateSelectInput(inputId = "x", choices = colnames(data()[[input$dataname]]))
          updateSelectInput(inputId = "y", choices = colnames(data()[[input$dataname]]))
        })

        plot_data <- debounce(
          reactive({
            req(input$dataname, input$x, input$y)
            within(data(),
              {
                plot <- ggplot2::ggplot(dataname, ggplot2::aes(x = x, y = y)) +
                  ggplot2::geom_point()
              },
              dataname = as.name(input$dataname),
              x = as.name(input$x),
              y = as.name(input$y)
            )
          }), 200
        )

        plot_data_decorated <- srv_teal_transform_data("decorate", data = plot_data, transforms = decorators)

        plot_r <- reactive({
          req(plot_data_decorated())
          plot_data_decorated()[["plot"]]
        })

        output$plot <- renderPlot(plot_r())
        output$text <- renderText({
          teal.code::get_code(req(plot_data_decorated()))
        })
      })
    },
    ui_args = list(decorators = decorators),
    server_args = list(decorators = decorators)
  )
}
```

### Application

```{r}
library(ggplot2)
app <- init(
  data = teal_data(iris = iris, mtcars = mtcars),
  modules = modules(
    tm_decorated_plot("identity"),
    tm_decorated_plot("no-ui", decorators = static_decorator),
    tm_decorated_plot("lang", decorators = static_decorator_lang),
    tm_decorated_plot("interactive", decorators = interactive_decorator),
    tm_decorated_plot("interactive-from lang", decorators = interactive_decorator_lang),
    tm_decorated_plot("from-fun", decorators = gg_xlab_decorator("plot")),
    tm_decorated_plot("failing", decorators = failing_decorator)
  )
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}
```

## Decorating Tables

### Example Module

```{r, eval=requireNamespace("DT")}
library(DT)

# Define a decorator module for customizing table appearance
custom_table_decorator <- teal_transform_module(
  ui = function(id) {
    ns <- NS(id)
    div(
      selectInput(
        ns("style"), 
        "Table Style", 
        choices = c("Default", "Striped", "Hover"), 
        selected = "Default"
      )
    )
  },
  server = function(id, data) {
    moduleServer(id, function(input, output, session) {
      reactive({
        req(data())
        within(data(), 
          {
            if (style == "Striped") {
              table <- 
                formatStyle(
                  table, 
                  columns = attr(table$x, "colnames")[-1], 
                  target = 'row', 
                  backgroundColor = '#f9f9f9'
                )
            } else if (style == "Hover") {
              table <- 
                formatStyle(
                  table, 
                  columns = attr(table$x, "colnames")[-1], 
                  target = 'row', 
                  backgroundColor = '#f0f0f0'
                )
            }
          }, 
          style = input$style
        )
      })
    })
  }
)

# Main module to display the table with the decorator applied
tm_custom_table <- function(label = "Customized Table Module", decorators = teal_transform_module()) {
  module(
    label = label,
    ui = function(id, decorators) {
      ns <- NS(id)
      div(
        selectInput(ns("dataset"), "Select Dataset", choices = NULL),
        ui_teal_transform_data(ns("decorate"), transforms = decorators),
        DT::dataTableOutput(ns("table_output")),
        verbatimTextOutput(ns("code_output"))
      )
    },
    server = function(id, data, decorators) {
      moduleServer(id, function(input, output, session) {
        observeEvent(data(), {
          updateSelectInput(inputId = "dataset", choices = names(data()))
        })
        
        base_table <- reactive({
          req(input$dataset)
          within(data(), 
            {
              table <- 
                DT::datatable(
                  dataset,
                  options = list(
                    dom = "t",
                    autoWidth = TRUE
                  )
                )
            }, 
            dataset = as.name(input$dataset)
          )
        })
        
        decorated_table <- 
          srv_teal_transform_data("decorate", data = base_table, transforms = decorators)
        
        output$table_output <- DT::renderDT({
          req(decorated_table())
          decorated_table()[["table"]]
        })
        
        output$code_output <- renderText({
          teal.code::get_code(req(decorated_table()))
        })
      })
    },
    ui_args = list(decorators = decorators),
    server_args = list(decorators = decorators)
  )
}
```

### Application

```{r, eval=requireNamespace("DT")}
app <- init(
  data = teal_data(mtcars = mtcars, iris = iris),
  modules = modules(
    tm_custom_table("custom_table", decorators = custom_table_decorator)
  )
)

if (interactive()) {
  shinyApp(app$ui, app$server)
}```
