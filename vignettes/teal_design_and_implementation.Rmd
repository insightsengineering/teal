---
title: "Teal Design and Implementation"
author: "Adrian Waddell"
date: "10/29/2017"
output: rmarkdown::html_vignette
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{Teal Design and Implementation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This vignette describes the core design of `teal` and explains some of `teal`'s
implementation details.

`teal` is a framework built on top of `Shiny` that adds:

- data filtering on a variable basis combined with `&` logic
- API to request the underlying R code of an output
- modularized approach to build customized web-apps with `teal` modules

`teal` modules are `Shiny` modules with an additional `datasets` argument for
the `server` function that provides an access to the filtered data.

# Shiny Basics

Shiny apps have the following two main components: the `server` function and an
`ui` object. The `ui` object is a representation of the `HTML` for the webpage
and the `server` function provides the logic to modify the HTML code. Hence, a
minimal Shiny app with no server logic is as follows:

```{r, echo=FALSE}
library(shiny)
```

```{r, eval = FALSE}
library(shiny)
shinyApp(
  ui = tags$p("Hello World"),
  server = function(input, output, session) NULL
)
```

You can paste this code to the `R` command line which will initialize the Shiny
app. `Shiny` provides a [reactivity programming model][shiny_reactivity] to
update and get information from the ui:

```{r, eval = FALSE}
shinyApp(
  ui = fluidPage(
    selectInput(
      inputId = "select_data",
      label = "select data",
      choices = c("iris", "mtcars")
    ),
    plotOutput(outputId = "scatterplotmatrix")
  ),
  server = function(input, output, session) {
    output$scatterplotmatrix <- renderPlot({
      data <- input$select_data
      if (data == "iris") {
        pairs(iris[, -5], col = iris$Species)
      } else {
        pairs(mtcars[, -2], col = mtcars$cyl)
      }
    })
  }
)
```

Note that reactivity is used on the server side for capturing the input (i.e.
`input$select_data`) and to update the output (i.e. `output$scatterplot`). On
the ui side Shiny keeps the `HTML` code up-to-date and propagates user interface
input changes to the reactive environment on the server side. Please inspect the
`HTML` code from the previous example app while the app is running with Chrome's
developer tools and then stop the Shiny app and compare that `HTML` code with the
ui code created by running the following code in the R console:

```{r, eval=FALSE}
fluidPage(
  selectInput(
    inputId = "select_data",
    label = "select data",
    choices = c("iris", "mtcars")
  ),
  plotOutput(outputId = "scatterplotmatrix")
)
```

[Shiny modules][shiny_modules] provide an elegant way to split both the _ui_
object and _server_ function into reusable and self-contained functions. Please
read the [official tutorial][shiny_modules] and note that input and output
elements are separated by using namespaces. For the above example, we can
modularize the selection and the plotting of the data as follows:

```{r}
ui_example <- function(id) {
  ns <- NS(id)
  tagList(
    selectInput(
      inputId = ns("select_data"),
      label = "select data",
      choices = c("iris", "mtcars")
    ),
    plotOutput(outputId = ns("scatterplotmatrix"))
  )
}

srv_example <- function(input, output, session) {
  output$scatterplotmatrix <- renderPlot({
    data <- input$select_data
    if (data == "iris") {
      pairs(iris[, -5], col = iris$Species)
    } else {
      pairs(mtcars[, -2], col = mtcars$cyl)
    }
  })
}
```

Note that `ui_example` and `srv_example` functions constitute our _example_
module. To use this module twice in an app run the following code:

```{r, eval = FALSE}
shinyApp(
  ui = function() {
    tagList(
      ui_example(id = "first"),
      ui_example(id = "second")
    )
  },
  server = function(input, output, session) {
    callModule(srv_example, id = "first")
    callModule(srv_example, id = "second")
  }
)
```

Note that because of the namespace `id` the two modules do not conflict with
their `HTML` ids and reactivity names. Please inspect the `HTML` code for the
above example and pay attention to the `HTML` `id` attributes.

Here is a visual representation of this modularization:

```{r echo=FALSE}
knitr::include_graphics("./images/design_shiny_module.png")
```

This modularized construction of Shiny apps is one of the foundations of `teal`.
Modularizing code also makes it easier to build a company wide standard for
creating and sharing Shiny code and also for creating project specific
applications quickly.

Finally, the user interface layout in the version of Shiny we currently support
is based on [Bootstrap 3][bootstrap_3] when
using the `fluidPage` and `fixedPage` layout functions (which we do for `teal`).
Understanding the bootstrap framework for layout, class and css association is
useful for creating clean user interfaces.

# The Teal Overall Design

The general `teal` workflow is as follows:

1. pass a collection of data sets and a collection of configured teal modules to
   the `teal::init` function.

2. `teal::init` composes the `ui` and `server` functions that can then be passed
   to the `shiny::shinyApp` function

```{r echo=FALSE}
knitr::include_graphics("./images/design_use_teal.png")
```

A simple example for a completely custom `teal` module is the following

```{r, eval = FALSE}
library(teal)

app <- teal::init(
  data = teal_data(teal.data::dataset("IRIS", x = iris)),
  modules = modules(
    module(
      label = "sample module",
      server = function(input, output, session, datasets) {
        output$scatterplot <- renderPlot({
          iris <- datasets$get_data("IRIS", filtered = TRUE)
          with(iris, plot(Sepal.Length, Sepal.Width, col = Species))
        })
      },
      ui = function(id, datasets) {
        ns <- NS(id)
        plotOutput(ns("scatterplot"))
      },
      filters = "IRIS"
    )
  )
)
shinyApp(app$ui, app$server)
```

Please run the above code by copy-pasting it to the command line. The example
shows how simple it is to create a module that has no dynamic encodings but
still is interactive due to the possibility of filtering the data.

The default `teal` web application has the following components:

```{r echo=FALSE}
knitr::include_graphics("./images/teal_containers.png")
```

- the composition of the Shiny app `ui` object is based on the [`tabsetPanel`]
- the composition of the `server` function is based on the modules as
  illustrated here:

```{r echo=FALSE}
knitr::include_graphics("./images/design_teal.png")
```

The important new parts in the above diagram are:

- the `datasets` object that filters the analysis data and provides an interface
  to access and modify the data and variable based filtering. The `datasets`
  object is of class `FilteredData` which uses the [`R6`][r6] object system.

- Filter panel related code: that is module encapsulated within `FilteredData`.

- Shiny's [`tabsetPanel`] for displaying only one analysis module at a time (e.g.
  the one with a bold outline). The modules that are not active (visible) get the
  attribute `class=invisible` in the HTML code. Note that the `HTML` for each
  module is always present in your app ui `HTML` code.

These have been the three main challenges (in addition to code reproducibility)
when designing and implementing `teal`. The relevant R-code for these main parts
are in the [teal repository][tealgithub] in the following files:

- `R/init.R`,

We now discuss each of the three core components in detail. This would be a good
time to browse through the just mentioned `.R` files and see how much of what
has just been said/written can be spotted in the code without further
explanation.

## `FilteredData`

The `FilteredData` class is an [`R6`][r6] reference class to handle the datasets
and the filtering state. In general, every dataset can be filtered based on
values of its variables.

- if a variable `xi` is continuous or date/date time then the filtering is based on a range: `xi in [a,b]` where `min(xi)<=a<b<=max(xi)`

- if a variable `xi` is categorical then the filtering is based on a set:
  `xi in A` where `A` is a subset of the elements in `xi`.

When filtering a dataset, say `ADSL`, with `10` of its variables then the `10`
subsetting conditions are combined with an logical AND (`&`). If a more
complicated subsetting is needed then it is easiest to add a new variable to the
analysis dataset that contains the desired logic which then in turn can be
combined via `&` logic with other variable based subsetting conditions.

### Clinical Trials Data

In order to understand the current implementation of the `FilteredData` class it
is useful to have some background of the data standards used in clinical trials.

For clinical trials the datasets are standardized following the [CDISC][cdisc]
standards [SDTM][sdtm] and [ADaM][adam]. Both SDTM and ADaM are based on
rectangular data structures and a simplified generalization is that SDTM
contains observed raw data and ADaM adds metadata and derives new data so that
an output (table/graph) can be computed directly from a single ADaM data set.
Here is a diagram of some SDTM datasets:

```{r echo=FALSE, out.width='80%'}
knitr::include_graphics("./images/sdtm_overview.png")
```

The names of ADaM datasets often prefix a `AD` or `A` to their corresponding
`SDTM` dataset names.

There is one particularly important dataset called `ADSL` or `ADLS` that contains
patient information (e.g. Unique Subject Identifier `USUBJID`, `ARM`, `SEX`,
`Age`, randomization date, etc.) with one row per patient. Often this dataset is
merged to all other `ADaM` datasets as its information is frequently used for
most outputs (e.g. `ARM`). The key for merging `ADSL` and any other analysis
dataset is the `USUBJID` and `STUDYID` variable (if not specified otherwise).

### `FilteredData` Class for Clinical Trials Data

`teal` supports both general relational data (using `teal_data` function output as
`data` argument to `teal::init`) and CDISC specific data (using `cdisc_data` function instead)

When using CDISC specific data, the filtering mechanism makes use of `ADSL`
being a "special" dataset as described below.

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics("./images/design_cdisc_filtered_datasets.png")
```

This filtering will now be explained step by step for two example datasets (`ADSL`
and `ADTTE`):

```{r}
# for reproducibility
set.seed(1)

ADSL <- data.frame( # nolint
  USUBJID = paste0("id-", 1:100),
  STUDYID = "studyA",
  AGE = abs(rnorm(100, sd = 20) + 40),
  SEX = sample(c("M", "F"), 100, TRUE),
  stringsAsFactors = FALSE
)

ADTTE <- data.frame( # nolint
  USUBJID = paste0("id-", 1:100),
  STUDYID = "studyA",
  AVAL = abs(rexp(100, rate = 1 / 20)),
  CNSR = sample(c(0, 1), 100, TRUE),
  PARAMCD = "OS",
  stringsAsFactors = FALSE
)

set.seed(0)
```

The `datasets` object of class `CDISCFilteredData`
that is passed an argument to the `server` function is created by `teal` as follows:

```{r}
library(teal)

datasets <- teal.slice:::CDISCFilteredData$new()
# the `datasets` object contains reactives
# we activate this option, so we don't need to wrap all reactives in isolate calls
options(shiny.suppressMissingContextError = TRUE)
datasets$set_dataset(teal.data::cdisc_dataset("ADSL", ADSL))
datasets$set_dataset(teal.data::cdisc_dataset("ADTTE", ADTTE))
shiny:::flushReact() # force evaluation outside of Shiny apps
```

Now say we want to filter out all the patients in `ADSL` except patients with `USUBJID`
equal to `id-1`, `id-2`, `id-3`, or `id-4`:

```{r}
datasets$set_filter_state(
  state = list(
    ADSL = list(
      USUBJID = sprintf("id-%s", 1:4)
    )
  )
)

datasets$get_data("ADSL", filtered = TRUE)
```

Note that this `USUBJID` variable based filtering also filters the `ADTE` data
(with an inner join based on `USUBJID` and `STUDYID`), as illustrated in the
previous figure:

```{r}
datasets$get_data("ADTTE", filtered = TRUE)
```

The two `get_data` method calls return the `ADSL_FILTERED` and `ADTTE_FILTERED`
data, respectively, as illustrated from the above figure. We can also get the
`call` object that was used for the filtering:

```{r}
cat(
  teal.slice::get_filter_expr(datasets, "ADTTE")
)
```

### `FilteredData` for general relational data

The CDISC filtering mechanism which we have introduced in the previous section
can be abstracted with the following diagram:

```{r echo=FALSE}
knitr::include_graphics("./images/design_cdisc_filtered_data.png")
```

This is, however, a very particular filtering setup that has not much use
besides analyzing clinical trials data that follows CDISC standards. A more
general filtering is to have variable based filtering for an
arbitrary dataset:

```{r echo=FALSE}
knitr::include_graphics("./images/design_one_dataset_filtered_data.png")
```

or more generally a collection of independently filtered datasets:

```{r echo=FALSE}
knitr::include_graphics("./images/design_simple_filtered_data.png")
```

This filtering is implemented using the `FilteredData` class
(which is created when using the `teal_data` and which `CDISCFilteredData` inherits from).

In the future we may also need filtering for [expression sets][expressionsets]

```{r echo=FALSE}
knitr::include_graphics("./images/expressionset.png")
```

that is, filtering expression sets is a slightly more advanced filtering as one
probably wants to filter the biomarker data on a sample level but also on
gene metadata level (filter columns and rows).

In terms of refactoring `teal` this means changes to the `FilteredData` class hierarchy

## Composition of the ui and server functions with `teal::init`

In this section we discuss the code in `R/init.R`. The `init` function composes
the `ui` object and the `server` function which are returned and then passed to
`shinyApp` to start the web app.

The datasets passed to the `data` arguments get encapsulated within the `init`
function into a local instance of `FilteredData` or `CDISCFilteredData`
(i.e. the `datasets` object).

Next, the `ui` object is created. The composition of ui and server happens
entirely with the object passed via `modules`, `header`, and `footers`
arguments. The `modules` object is a tree of `modules()` (nested lists) with
currently a constrained depth of 2. The composition of the ui functions defined
in `modules` happens recursively via the `create_ui` function. Note that the
`create_ui` function call happens in a local environment as we modify the
returned object structure to add the filter panel on the right hand side (this
improves the UI as it places the filter panel below the `tabsetPanel` menu).

Also note that the added javascript in the `ui` object is necessary to manually
interrupt reactivity when hiding the ui elements for filtering based on variables
that are not relevant for a particular analysis (i.e. we do not show `ADRS`
filter variables if we analyse an output based on `ADTTE`).

Next: the creation of the server function. The easy part is the composition of
the module server functions which happens with the `call_modules` function call.

# Embed teal into other applications

Here is an example of an app with two independent teal applications side-by-side. The same idea can be used to embed it into other Shiny modules.
We use the `id` argument of the `init` function for this.

```{r, eval=FALSE}
library(scda)

ADSL <- synthetic_cdisc_data("latest")$adsl # nolint

# Code to have two teal apps side-by-side or embed it in a larger application
create_teal_app <- function(title, id) {
  init(
    data = cdisc_data(
      cdisc_dataset("ADSL", ADSL, code = "ADSL <- synthetic_cdisc_data(\"latest\")$adsl")
    ),
    modules = modules(
      module(
        "data source",
        server = function(input, output, session, datasets) NULL,
        ui = function(id, ...) div(p("information about data source")),
        filters = "all"
      ),
      module(
        "ADSL AGE histogram",
        server = function(input, output, session, datasets) {
          output$hist <- renderPlot(hist(datasets$get_data("ADSL", filtered = TRUE)$AGE))
        },
        ui = function(id, ...) {
          ns <- NS(id)
          plotOutput(ns("hist"))
        },
        filters = "ADSL"
      )
    ),
    filter = list(ADSL = list(AGE = c(20, 50))),
    header = tags$h1(title),
    footer = tags$p("Copyright 2017 - 2020"),
    id = id
  )
}
app1 <- create_teal_app("Sample App1", id = "app1")
app2 <- create_teal_app("Sample App2", id = "app2")
shinyApp(
  ui = fluidPage(fluidRow(
    column(6, app1$ui),
    column(6, app2$ui)
  )),
  server = function(input, output, session) {
    callModule(app1$server, "app1")
    callModule(app2$server, "app2")
  }
)
```

[shiny_modules]: https://shiny.rstudio.com/articles/modules.html
[shiny_reactivity]: https://shiny.rstudio.com/articles/reactivity-overview.html
[bootstrap_3]: http://bootstrapdocs.com/v3.0.3/docs/
[r6]: https://r6.r-lib.org/articles/Introduction.html
[sdtm]: https://www.cdisc.org/standards/foundational/sdtm
[adam]: https://www.cdisc.org/standards/foundational/adam
[cdisc]: https://www.cdisc.org
[tabsetpanel]: https://shiny.rstudio.com/reference/shiny/1.0.5/tabsetPanel.html
[tealgithub]: https://github.com/insightsengineering/teal
[expressionsets]: https://www.bioconductor.org/packages/3.7/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf
